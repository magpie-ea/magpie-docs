{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"_babe: basic architecture for browser experiments A quick start guide can be found here .","title":"_babe: basic architecture for browser experiments"},{"location":"#_babe-basic-architecture-for-browser-experiments","text":"A quick start guide can be found here .","title":"_babe: basic architecture for browser experiments"},{"location":"04_development/","text":"Development To get the development version of the _babe package, clone this repository and install the dependencies by running npm install in the terminal. Workflow branches: master - Current stable version. development - Development version. This is where new featues or bug fixes are pushed. When the version is stable, the branch is merged into master. (1) Source files src/ babe-canvas.js babe-errors.js babe-init.js babe-progress-bar.js babe-submit.js babe-utils.js babe-views.js babe.css (2) Create babe.js and babe.full.js Option 1: Build the _babe package files while developing Use npm run watch command from the babe-project folder to start a process which watches for changes in the files in src and builds (updates) babe.js and babe.full.js . This commands builds both babe.js and babe.full.js when a file in src is saved. Option 2: Make changes to the files and then build the _babe files Run npm run concat from the babe-project folder. This command builds both babe.js and babe.full.js . (3) Merge into master include a changelog information in the README merge to master update the version of _babe in package.json (4) Publish to npm Run npm publish from the babe-project folder to publish the new version of _babe.","title":"Development"},{"location":"04_development/#development","text":"To get the development version of the _babe package, clone this repository and install the dependencies by running npm install in the terminal.","title":"Development"},{"location":"04_development/#workflow","text":"branches: master - Current stable version. development - Development version. This is where new featues or bug fixes are pushed. When the version is stable, the branch is merged into master.","title":"Workflow"},{"location":"04_development/#1-source-files","text":"src/ babe-canvas.js babe-errors.js babe-init.js babe-progress-bar.js babe-submit.js babe-utils.js babe-views.js babe.css","title":"(1) Source files"},{"location":"04_development/#2-create-babejs-and-babefulljs","text":"","title":"(2) Create babe.js and babe.full.js"},{"location":"04_development/#option-1-build-the-95babe-package-files-while-developing","text":"Use npm run watch command from the babe-project folder to start a process which watches for changes in the files in src and builds (updates) babe.js and babe.full.js . This commands builds both babe.js and babe.full.js when a file in src is saved.","title":"Option 1: Build the _babe package files while developing"},{"location":"04_development/#option-2-make-changes-to-the-files-and-then-build-the-95babe-files","text":"Run npm run concat from the babe-project folder. This command builds both babe.js and babe.full.js .","title":"Option 2: Make changes to the files and then build the _babe files"},{"location":"04_development/#3-merge-into-master","text":"include a changelog information in the README merge to master update the version of _babe in package.json","title":"(3) Merge into master"},{"location":"04_development/#4-publish-to-npm","text":"Run npm publish from the babe-project folder to publish the new version of _babe.","title":"(4) Publish to npm"},{"location":"05_about/","text":"_babe has been developed for open science by open scientists: Stela Ilieva Xiang Ji Jannis Rautenstrauch Michael Franke _babe has been supported financially by the Priority Program XPrag.de (DFG Schwerpunktprogramm 1727) and the SFB 833 Constitution of Meaning . We encourage your participation. Please raise an issue on GitHub when you have reason to. Also, please submit your own experiments to complete the list of templates.","title":"About"},{"location":"01_designing_experiments/01_template_views/","text":"Template views Wrapping views Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. All wrapping views have two obligatory fields : trials: int the number of trials this view will be cycled through name: string the unique name of this view instance Intro view Instantiate with babeViews.view_generator('intro', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default Instructions view Instantiate with babeViews.view_generator('instructions', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default Begin view Instantiate with babeViews.view_generator('begin, ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default Post_test view Instantiate with babeViews.view_generator('post_test', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)' Thanks view Instantiate with babeViews.view_generator('thanks', ...) . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific' Trial views Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int the number of trials this view will appear name: string the name of the view data: array list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below. Forced-choice task Instantiate with babeViews.view_generator('forced_choice', ...) Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ]; Sentence Choice task Instantiate with babeViews.view_generator('sentence_choice', ...) . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Image Selection task Instantiate with babeViews.view_generator('image_seletion', ...) . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about babe canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ]; Textbox Input task Instantiate with babeViews.view_generator('textbox_input', ...) . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like? like?\", min_chars: 50 } ]; Slider Rating task Instantiate with babeViews.view_generator('slider_rating', ...) . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like? like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ]; Dropdown Choice task Instantiate with babeViews.view_generator(drowdown_choice', ...) . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Rating Scale task Instantiate with babeViews.view_generator('rating_scale', ...) . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Key Press task Instantiate with babeViews.view_generator('key_press', ...) . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about babe canvas Sample data const key_press_trials = [ { question: \"What's the weather like? like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ]; Self-paced reading There are templates for realizing self-paced reading tasks too. Self-paced reading with forced choice response Instantiate with babeViews.view_generator('self_paced_reading', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about babe canvas question: string Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\" } ]; Self-paced reading task with rating scale response Instantiate with babeViews.view_generator('self_paced_reading_rating_scale', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about babe canvas question: string const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ];","title":"Template views"},{"location":"01_designing_experiments/01_template_views/#template-views","text":"","title":"Template views"},{"location":"01_designing_experiments/01_template_views/#wrapping-views","text":"Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. All wrapping views have two obligatory fields : trials: int the number of trials this view will be cycled through name: string the unique name of this view instance","title":"Wrapping views"},{"location":"01_designing_experiments/01_template_views/#intro-view","text":"Instantiate with babeViews.view_generator('intro', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default","title":"Intro view"},{"location":"01_designing_experiments/01_template_views/#instructions-view","text":"Instantiate with babeViews.view_generator('instructions', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default","title":"Instructions view"},{"location":"01_designing_experiments/01_template_views/#begin-view","text":"Instantiate with babeViews.view_generator('begin, ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default","title":"Begin view"},{"location":"01_designing_experiments/01_template_views/#post_test-view","text":"Instantiate with babeViews.view_generator('post_test', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)'","title":"Post_test view"},{"location":"01_designing_experiments/01_template_views/#thanks-view","text":"Instantiate with babeViews.view_generator('thanks', ...) . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific'","title":"Thanks view"},{"location":"01_designing_experiments/01_template_views/#trial-views","text":"Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int the number of trials this view will appear name: string the name of the view data: array list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below.","title":"Trial views"},{"location":"01_designing_experiments/01_template_views/#forced-choice-task","text":"Instantiate with babeViews.view_generator('forced_choice', ...) Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ];","title":"Forced-choice task"},{"location":"01_designing_experiments/01_template_views/#sentence-choice-task","text":"Instantiate with babeViews.view_generator('sentence_choice', ...) . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Sentence Choice task"},{"location":"01_designing_experiments/01_template_views/#image-selection-task","text":"Instantiate with babeViews.view_generator('image_seletion', ...) . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about babe canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ];","title":"Image Selection task"},{"location":"01_designing_experiments/01_template_views/#textbox-input-task","text":"Instantiate with babeViews.view_generator('textbox_input', ...) . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like? like?\", min_chars: 50 } ];","title":"Textbox Input task"},{"location":"01_designing_experiments/01_template_views/#slider-rating-task","text":"Instantiate with babeViews.view_generator('slider_rating', ...) . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like? like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ];","title":"Slider Rating task"},{"location":"01_designing_experiments/01_template_views/#dropdown-choice-task","text":"Instantiate with babeViews.view_generator(drowdown_choice', ...) . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Dropdown Choice task"},{"location":"01_designing_experiments/01_template_views/#rating-scale-task","text":"Instantiate with babeViews.view_generator('rating_scale', ...) . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Rating Scale task"},{"location":"01_designing_experiments/01_template_views/#key-press-task","text":"Instantiate with babeViews.view_generator('key_press', ...) . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about babe canvas Sample data const key_press_trials = [ { question: \"What's the weather like? like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ];","title":"Key Press task"},{"location":"01_designing_experiments/01_template_views/#self-paced-reading","text":"There are templates for realizing self-paced reading tasks too.","title":"Self-paced reading"},{"location":"01_designing_experiments/01_template_views/#self-paced-reading-with-forced-choice-response","text":"Instantiate with babeViews.view_generator('self_paced_reading', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about babe canvas question: string Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\" } ];","title":"Self-paced reading with forced choice response"},{"location":"01_designing_experiments/01_template_views/#self-paced-reading-task-with-rating-scale-response","text":"Instantiate with babeViews.view_generator('self_paced_reading_rating_scale', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about babe canvas question: string const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ];","title":"Self-paced reading task with rating scale response"},{"location":"01_designing_experiments/01_views/","text":"... coming soon ... general information about the design of a _babe experiment There are two types of views: trial type and wrapping views. _babe provides a number of templates to create views with a pre-given structure.","title":"01 views"},{"location":"01_designing_experiments/02_template_views/","text":"","title":"02 template views"},{"location":"01_designing_experiments/02a_wrapping_views/","text":"Wrapping views Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Intro view Instantiate with babeViews.intro . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default Instructions view Instantiate with babeViews.instructions . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default Begin view Instantiate with babeViews.begin . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default PostTest view Instantiate with babeViews.postTest . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)' Thanks view Instantiate with babeViews.thanks . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific'","title":"Wrapping views"},{"location":"01_designing_experiments/02a_wrapping_views/#wrapping-views","text":"Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment.","title":"Wrapping views"},{"location":"01_designing_experiments/02a_wrapping_views/#intro-view","text":"Instantiate with babeViews.intro . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default","title":"Intro view"},{"location":"01_designing_experiments/02a_wrapping_views/#instructions-view","text":"Instantiate with babeViews.instructions . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default","title":"Instructions view"},{"location":"01_designing_experiments/02a_wrapping_views/#begin-view","text":"Instantiate with babeViews.begin . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default","title":"Begin view"},{"location":"01_designing_experiments/02a_wrapping_views/#posttest-view","text":"Instantiate with babeViews.postTest . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)'","title":"PostTest view"},{"location":"01_designing_experiments/02a_wrapping_views/#thanks-view","text":"Instantiate with babeViews.thanks . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific'","title":"Thanks view"},{"location":"01_designing_experiments/02b_trial_views/","text":"Trial views Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int - the number of trials this view will appear name: string - the name of the view data: array - list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below. Forced-choice task Instantiate with babeView.forcedChoice . Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ]; Sentence Choice task Instantiate with babeViews.sentenceChoice . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Image Selection task Instantiate with babeViews.imageSelection . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about babe canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ]; Textbox Input task Instantiate with babeViews.textboxInput . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like? like?\", min_chars: 50 } ]; Slider Rating task Instantiate with babeViews.sliderRating . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like? like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ]; Dropdown Choice task Instantiate with babeViews.dropdownChoice . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Rating Scale task Instantiate with babeViews.ratingScale . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Key Press task Instantiate with babeViews.keyPress . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about babe canvas Sample data const key_press_trials = [ { question: \"What's the weather like? like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ];","title":"Trial views"},{"location":"01_designing_experiments/02b_trial_views/#trial-views","text":"Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int - the number of trials this view will appear name: string - the name of the view data: array - list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below.","title":"Trial views"},{"location":"01_designing_experiments/02b_trial_views/#forced-choice-task","text":"Instantiate with babeView.forcedChoice . Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ];","title":"Forced-choice task"},{"location":"01_designing_experiments/02b_trial_views/#sentence-choice-task","text":"Instantiate with babeViews.sentenceChoice . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Sentence Choice task"},{"location":"01_designing_experiments/02b_trial_views/#image-selection-task","text":"Instantiate with babeViews.imageSelection . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about babe canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ];","title":"Image Selection task"},{"location":"01_designing_experiments/02b_trial_views/#textbox-input-task","text":"Instantiate with babeViews.textboxInput . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like? like?\", min_chars: 50 } ];","title":"Textbox Input task"},{"location":"01_designing_experiments/02b_trial_views/#slider-rating-task","text":"Instantiate with babeViews.sliderRating . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like? like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ];","title":"Slider Rating task"},{"location":"01_designing_experiments/02b_trial_views/#dropdown-choice-task","text":"Instantiate with babeViews.dropdownChoice . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Dropdown Choice task"},{"location":"01_designing_experiments/02b_trial_views/#rating-scale-task","text":"Instantiate with babeViews.ratingScale . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about babe canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Rating Scale task"},{"location":"01_designing_experiments/02b_trial_views/#key-press-task","text":"Instantiate with babeViews.keyPress . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about babe canvas Sample data const key_press_trials = [ { question: \"What's the weather like? like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ];","title":"Key Press task"},{"location":"01_designing_experiments/02c_SPR/","text":"Self-paced reading There are templates for realizing self-paced reading tasks too. Self-paced reading with forced choice response Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about babe canvas question: string Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\" } ]; Self-paced reading task with rating scale response Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about babe canvas question: string const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ];","title":"Self-paced reading"},{"location":"01_designing_experiments/02c_SPR/#self-paced-reading","text":"There are templates for realizing self-paced reading tasks too.","title":"Self-paced reading"},{"location":"01_designing_experiments/02c_SPR/#self-paced-reading-with-forced-choice-response","text":"Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about babe canvas question: string Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\" } ];","title":"Self-paced reading with forced choice response"},{"location":"01_designing_experiments/02c_SPR/#self-paced-reading-task-with-rating-scale-response","text":"Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about babe canvas question: string const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ];","title":"Self-paced reading task with rating scale response"},{"location":"01_designing_experiments/03_custom_views/","text":"... information to be added soon ...","title":"Custom views"},{"location":"01_designing_experiments/03_miscellaneous/","text":"Progress bars progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displayed. Global information","title":"Progress bars"},{"location":"01_designing_experiments/03_miscellaneous/#progress-bars","text":"progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displayed.","title":"Progress bars"},{"location":"01_designing_experiments/03_miscellaneous/#global-information","text":"","title":"Global information"},{"location":"01_designing_experiments/04_lifecycles_hooks/","text":"Life cycles and hooks All trial views have a fixed life cycle that you can use to manipulate the timing of events during a trial. You can insert custom functions, so-called 'hooks' to massage template views into style. Life cycles All the trial views go through the following steps. pause step :: show a blank screen for specified time enable by passing pause: number (in miliseconds) defaults to pause: 0 shows nothing but a blank screen and the QUD if there is such fixation point step :: show fixation cross in the middle where the stimulus appears for specified time enabled by setting fix_duration: number (in miliseconds) defaults to fix_duration: 0 shows a cross in the middle of the stimulus and the QUD if there is such stimulus shown step :: stimulus appears stimulus hidden step :: hides the stimulus from the screen set by passing stim_duration: number (in miliseconds) defaults to stim_duration: Infinity hide the stimulus when SPACE gets pressed with stim_duration: 'space' skip this step by not defining stim_duration response enabled step :: the participant can interact with the view (respond, read the sentence etc.** Example Suppose you want to add a 1000 ms inter-stimulus break between two trials and show a fixation cross for 250 ms. You could realize this when instantiating your view like this: const forced_choice_2A = babeViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, pause: 1000, fix_duration: 250 }); Hooks For minor customization of the template views, you can create functions, ideally in file 02_custom_functions.js and hook these functions to specific steps in the life cycle of a trial view. The following hooks exist where your custom functions could attach: after the pause is finished enable with hook.after_pause: _function_ after the fixation point hides enable with hook.after_fix_point: _function_ after the stimulus is shown enable with hook.after_stim_shown: _function_ after the stimulus hides enable with hook.after_stim_hidden: _function_ after the interactions are enabled enable with hook.after_response_enabled: _function_ Your custom functions get the trial data for each trial view and next as arguments. You can use the data if you need to. To proceed to the next step of the lifecycle, you have to call next() Full lifecycle - hook sample pause shows pause finishes after_pause function called fixation point shows fixation point disappears after_fix_point function called stimulus shows after_stim_shown function called stimlus hides after_stim_hidden function called response is enabled after_response_enabled function called Example: response check Imagine you want to tell the participants whether their choice was right or wrong, e.g., during practice trials. We could realize this with a function which checks the answer for correctness which is hooked to the \"response-enabled step\". Of course, your data for each trial needs to include the information which answer is correct. For the Departure-Point example, we could add this information to 04_trials.js like so: forced_choice: [ { question: \"What's on the bread?\", picture: \"images/question_mark_02.png\", option1: 'jam', option2: 'ham', correct: 'jam' // which option is correct? }, { question: \"What's the weather like?\", picture: \"images/weather.jpg\", option1: \"shiny\", option2: \"rainbow\", correct: \"shiny\" // which option is correct? } ] We then define the function to be hooked, ideally in file 02_custom_functions.js : // compares the chosen answer to the value of `option1` check_response = function(data, next) { $('input[name=answer]').on('change', function(e) { if (e.target.value === data.correct) { alert('Your answer is correct! Yey!'); } else { alert('Sorry, this answer is incorrect :( The correct answer was ' + data.correct); } next(); }) } We then add this function to be called after the relevant step when creating the relevant view: const forced_choice_2A = babeViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, hook: { after_response_enabled: check_response } });","title":"Life cycles and hooks"},{"location":"01_designing_experiments/04_lifecycles_hooks/#life-cycles-and-hooks","text":"All trial views have a fixed life cycle that you can use to manipulate the timing of events during a trial. You can insert custom functions, so-called 'hooks' to massage template views into style.","title":"Life cycles and hooks"},{"location":"01_designing_experiments/04_lifecycles_hooks/#life-cycles","text":"All the trial views go through the following steps. pause step :: show a blank screen for specified time enable by passing pause: number (in miliseconds) defaults to pause: 0 shows nothing but a blank screen and the QUD if there is such fixation point step :: show fixation cross in the middle where the stimulus appears for specified time enabled by setting fix_duration: number (in miliseconds) defaults to fix_duration: 0 shows a cross in the middle of the stimulus and the QUD if there is such stimulus shown step :: stimulus appears stimulus hidden step :: hides the stimulus from the screen set by passing stim_duration: number (in miliseconds) defaults to stim_duration: Infinity hide the stimulus when SPACE gets pressed with stim_duration: 'space' skip this step by not defining stim_duration response enabled step :: the participant can interact with the view (respond, read the sentence etc.** Example Suppose you want to add a 1000 ms inter-stimulus break between two trials and show a fixation cross for 250 ms. You could realize this when instantiating your view like this: const forced_choice_2A = babeViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, pause: 1000, fix_duration: 250 });","title":"Life cycles"},{"location":"01_designing_experiments/04_lifecycles_hooks/#hooks","text":"For minor customization of the template views, you can create functions, ideally in file 02_custom_functions.js and hook these functions to specific steps in the life cycle of a trial view. The following hooks exist where your custom functions could attach: after the pause is finished enable with hook.after_pause: _function_ after the fixation point hides enable with hook.after_fix_point: _function_ after the stimulus is shown enable with hook.after_stim_shown: _function_ after the stimulus hides enable with hook.after_stim_hidden: _function_ after the interactions are enabled enable with hook.after_response_enabled: _function_ Your custom functions get the trial data for each trial view and next as arguments. You can use the data if you need to. To proceed to the next step of the lifecycle, you have to call next() Full lifecycle - hook sample pause shows pause finishes after_pause function called fixation point shows fixation point disappears after_fix_point function called stimulus shows after_stim_shown function called stimlus hides after_stim_hidden function called response is enabled after_response_enabled function called Example: response check Imagine you want to tell the participants whether their choice was right or wrong, e.g., during practice trials. We could realize this with a function which checks the answer for correctness which is hooked to the \"response-enabled step\". Of course, your data for each trial needs to include the information which answer is correct. For the Departure-Point example, we could add this information to 04_trials.js like so: forced_choice: [ { question: \"What's on the bread?\", picture: \"images/question_mark_02.png\", option1: 'jam', option2: 'ham', correct: 'jam' // which option is correct? }, { question: \"What's the weather like?\", picture: \"images/weather.jpg\", option1: \"shiny\", option2: \"rainbow\", correct: \"shiny\" // which option is correct? } ] We then define the function to be hooked, ideally in file 02_custom_functions.js : // compares the chosen answer to the value of `option1` check_response = function(data, next) { $('input[name=answer]').on('change', function(e) { if (e.target.value === data.correct) { alert('Your answer is correct! Yey!'); } else { alert('Sorry, this answer is incorrect :( The correct answer was ' + data.correct); } next(); }) } We then add this function to be called after the relevant step when creating the relevant view: const forced_choice_2A = babeViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, hook: { after_response_enabled: check_response } });","title":"Hooks"},{"location":"01_designing_experiments/05_canvas/","text":"Canvas Each babe trial type view can use the babe canvas api to create a picture of elements in the trial view. babe provides three types of element placement: random placement grid placement split grid placement How to use babe canvas To generate a picture of shapes, all you need is to have canvas object with some properties in the data your views use. For example: let trials = [ ..., { question: \"Are there any blue squares on the screen?\", option1: 'yes', option2: 'no', canvas: { focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } }, ... ]; Data format obligatory properties sort - the way the elements are arranged on the canvas. sort: 'random' - randomly placed on the canvas. start_with does not have an effect with this arrangement method; sort: 'grid' - placed in a grid. Uses canvas.canvas.rows ; sort: 'split_grid' - placed in a grid that is split in the middle. elemSize - the size of the element's shapes (in pixels). total - the total elements that are drawn on the canvas. focalColor - the color of the focal elements. focalNumber - the number of focal elements wanted on the canvas. focalShape - the shape of the foca elements (can be 'triangle', 'circle' or 'square') otherColor - the color of the other elements otherShape - the shape of the elements (can be 'triangle', 'circle' or 'square') The number of the other elements is total - focal.number optional properties Grid placement and split Grid Placement extra properties rows the number of grid rows. Placed in one row of not given. start_with - the grid and split_grid coordinates are generated from left to right. By default first the focal elements are placed on the canvas so they always appear on the left unless start_with is set to 'other' start_with: 'focal' : places the focal shapes first (from left to right) not set start_with places the focal shapes first (from left to right) start_with: 'other' : places the other shapes first (from left to right) Split Grid extra properties gap - the gap between the two sides. The default gap is 1.5 * elemSize direction - the direction in which the elements are placed. Set to 'row' if not given. 'row' - in a row, starting from left to right, ignoring the gap between the two sides; 'side_row' - in a row starting from left to right, not ignoring the gap, i.e. first finishes with the left side and then moves to the right; 'column' - in a column, starting from top left. canvas element settings You can add a canvasSettings object to your canvas if you want to set the height, width and background of the canvas. for example: canvas: { canvasSettings: { height: 600, width: 800, backrgound: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } If not passed the canvas's - height is 300 (300px) - width is 500 (500px) - background is 'white' Examples canvas: { canvasSettings: { background: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 4, otherShape: 'circle', otherColor: 'white', sort: 'split_grid', rows: 4, direction: 'side_row', elemSize: 30, total: 10 } // gap is default (1.5 * elemSize) // start_with is default (focal elem) canvas: { canvasSettings: { height: 500, width: 700 }, focalColor: 'blue', focalShape: 'circle', focalNumber: 25, otherShape: 'circle', otherColor: 'green', sort: 'random', elemSize: 10, total: 100 } // the canvas size is increased to fit 100 elements canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 1, otherShape: 'triangle', otherColor: 'green', sort: 'random', elemSize: 30, total: 10 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', start_with: 'other', rows: 2, direction: 'side_row', elemSize: 30, total: 16 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, elemSize: 30, total: 16 } // the default direction is 'row' canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 10, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, direction: 'column' elemSize: 30, total: 16 } // direction is default ('row') // start_with is default (focal elem) ``` canvas: { focalColor: 'grey', focalShape: 'circle', focalNumber: 6, otherShape: 'square', otherColor: 'blue', sort: 'grid', rows: 3, elemSize: 30, total: 18 } // start_with is default (focal elem)","title":"Canvas"},{"location":"01_designing_experiments/05_canvas/#canvas","text":"Each babe trial type view can use the babe canvas api to create a picture of elements in the trial view. babe provides three types of element placement: random placement grid placement split grid placement","title":"Canvas"},{"location":"01_designing_experiments/05_canvas/#how-to-use-babe-canvas","text":"To generate a picture of shapes, all you need is to have canvas object with some properties in the data your views use. For example: let trials = [ ..., { question: \"Are there any blue squares on the screen?\", option1: 'yes', option2: 'no', canvas: { focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } }, ... ];","title":"How to use babe canvas"},{"location":"01_designing_experiments/05_canvas/#data-format","text":"","title":"Data format"},{"location":"01_designing_experiments/05_canvas/#obligatory-properties","text":"sort - the way the elements are arranged on the canvas. sort: 'random' - randomly placed on the canvas. start_with does not have an effect with this arrangement method; sort: 'grid' - placed in a grid. Uses canvas.canvas.rows ; sort: 'split_grid' - placed in a grid that is split in the middle. elemSize - the size of the element's shapes (in pixels). total - the total elements that are drawn on the canvas. focalColor - the color of the focal elements. focalNumber - the number of focal elements wanted on the canvas. focalShape - the shape of the foca elements (can be 'triangle', 'circle' or 'square') otherColor - the color of the other elements otherShape - the shape of the elements (can be 'triangle', 'circle' or 'square') The number of the other elements is total - focal.number","title":"obligatory properties"},{"location":"01_designing_experiments/05_canvas/#optional-properties","text":"","title":"optional properties"},{"location":"01_designing_experiments/05_canvas/#grid-placement-and-split-grid-placement-extra-properties","text":"rows the number of grid rows. Placed in one row of not given. start_with - the grid and split_grid coordinates are generated from left to right. By default first the focal elements are placed on the canvas so they always appear on the left unless start_with is set to 'other' start_with: 'focal' : places the focal shapes first (from left to right) not set start_with places the focal shapes first (from left to right) start_with: 'other' : places the other shapes first (from left to right)","title":"Grid placement and split Grid Placement extra properties"},{"location":"01_designing_experiments/05_canvas/#split-grid-extra-properties","text":"gap - the gap between the two sides. The default gap is 1.5 * elemSize direction - the direction in which the elements are placed. Set to 'row' if not given. 'row' - in a row, starting from left to right, ignoring the gap between the two sides; 'side_row' - in a row starting from left to right, not ignoring the gap, i.e. first finishes with the left side and then moves to the right; 'column' - in a column, starting from top left.","title":"Split Grid extra properties"},{"location":"01_designing_experiments/05_canvas/#canvas-element-settings","text":"You can add a canvasSettings object to your canvas if you want to set the height, width and background of the canvas. for example: canvas: { canvasSettings: { height: 600, width: 800, backrgound: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } If not passed the canvas's - height is 300 (300px) - width is 500 (500px) - background is 'white'","title":"canvas element settings"},{"location":"01_designing_experiments/05_canvas/#examples","text":"canvas: { canvasSettings: { background: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 4, otherShape: 'circle', otherColor: 'white', sort: 'split_grid', rows: 4, direction: 'side_row', elemSize: 30, total: 10 } // gap is default (1.5 * elemSize) // start_with is default (focal elem) canvas: { canvasSettings: { height: 500, width: 700 }, focalColor: 'blue', focalShape: 'circle', focalNumber: 25, otherShape: 'circle', otherColor: 'green', sort: 'random', elemSize: 10, total: 100 } // the canvas size is increased to fit 100 elements canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 1, otherShape: 'triangle', otherColor: 'green', sort: 'random', elemSize: 30, total: 10 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', start_with: 'other', rows: 2, direction: 'side_row', elemSize: 30, total: 16 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, elemSize: 30, total: 16 } // the default direction is 'row' canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 10, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, direction: 'column' elemSize: 30, total: 16 } // direction is default ('row') // start_with is default (focal elem) ``` canvas: { focalColor: 'grey', focalShape: 'circle', focalNumber: 6, otherShape: 'square', otherColor: 'blue', sort: 'grid', rows: 3, elemSize: 30, total: 18 } // start_with is default (focal elem)","title":"Examples"},{"location":"01_designing_experiments/06_complex_experiments/","text":"","title":"06 complex experiments"},{"location":"01_designing_experiments/06_progress_bars/","text":"Progress bars _babe provides the option to include progress bars in selected views. For example, when you have defined views for variables practice and main , you can include progress bars for these views by specifying this information during the creation of the _babe object, like so: $(\"document\").ready(function() { babeInit({ ... progress_bar: { in: [ practice.name, main.name ], // only the practice and the main view will have progress bars in this experiment style: \"chunks\", // there will be two chunks - one for the practice and one for the main view width: 100 // each one of the two chunks will be 100 pixels long } }); }); Notice that the array progress.in requires not the variables, but the view's names (as strings). It is therefore important that each view receives its own unique name. You can use one of the following 3 styles (see pictues below): separate - shows a single bar which tracks progress within the current view default - shows a single bar which tracks progress within the whole experiment (all views designated for progress tracking) chunks - shows multiple bars, one for each progress-tracked view Use progress_bar.width to set the width (in pixels** of the progress bars. Examples progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displyed.","title":"Progress bars"},{"location":"01_designing_experiments/06_progress_bars/#progress-bars","text":"_babe provides the option to include progress bars in selected views. For example, when you have defined views for variables practice and main , you can include progress bars for these views by specifying this information during the creation of the _babe object, like so: $(\"document\").ready(function() { babeInit({ ... progress_bar: { in: [ practice.name, main.name ], // only the practice and the main view will have progress bars in this experiment style: \"chunks\", // there will be two chunks - one for the practice and one for the main view width: 100 // each one of the two chunks will be 100 pixels long } }); }); Notice that the array progress.in requires not the variables, but the view's names (as strings). It is therefore important that each view receives its own unique name. You can use one of the following 3 styles (see pictues below): separate - shows a single bar which tracks progress within the current view default - shows a single bar which tracks progress within the whole experiment (all views designated for progress tracking) chunks - shows multiple bars, one for each progress-tracked view Use progress_bar.width to set the width (in pixels** of the progress bars. Examples progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displyed.","title":"Progress bars"},{"location":"02_using_the_server_app/01_installation/","text":"Installation You can install _babe on a server for online use or locally on your machine. We explain here how to use Heroku as a hosting service for online use, and how to set up the server app locally. Installation on Heroku The _babe server app can be hosted on any hosting service or your own server. We here describe the process for installation on Heroku . Heroku makes it easy to deploy an web app without having to manually manage the infrastructure. It has a free starter tier, which should be sufficient for the purpose of running experiments. There is an official guide on how to deploy the Phoenix framework on Heroku. The deployment procedure is based on this guide, but differs in some places. {:start=\"0\"} 0. Ensure that you have the Phoenix Framework installed and working. However, if you just want to deploy this server and do no development work/change on it at all, you may skip this step. Ensure that you have a Heroku account already, and have the Heroku CLI installed and working on your computer. Ensure you have Git installed. Clone this git repo with git clone https://github.com/babe-project/BABE or git clone git@github.com:babe-project/BABE.git . cd into the project directory just cloned from your Terminal (or cmd.exe on Windows). Run heroku create --buildpack \"https://github.com/HashNuke/heroku-buildpack-elixir.git\" Run heroku buildpacks:add https://github.com/gjaldon/heroku-buildpack-phoenix-static.git (N.B.: Although the command line output tells you to run git push heroku master , don't do it yet.) You may want to change the application name instead of using the default name. In that case, run heroku apps:rename newname . Edit line 17 of the file config/prod.exs . Replace the part babe-backend.herokuapp.com after host with the app name (shown when you first ran heroku create , e.g. mysterious-meadow-6277.herokuapp.com , or the app name that you set at step 6, e.g. newname.herokuapp.com ). You shouldn't need to modify anything else. Ensure that you're at the top-level project directory. Run heroku addons:create heroku-postgresql:hobby-dev heroku config:set POOL_SIZE=18 Run mix deps.get then mix phx.gen.secret . Then run heroku config:set SECRET_KEY_BASE=\"OUTPUT\" , where OUTPUT should be the output of the mix phx.gen.secret step. Note: If you don't have the Phoenix framework installed on your computer, you may choose to use some other random generator for this task, which essentially asks for a random 64-character secret. On Mac and Linux, you may run openssl rand -base64 64 . Or you may use an online password generator such as the one offered by LastPass . Run git add config/prod.exs , then git commit -m \"Set app URL\" . Don't forget to set the environment variables AUTH_USERNAME and AUTH_PASSWORD , either in the Heroku web interface or via the command line, i.e. heroku config:set AUTH_USERNAME=\"your_username\" heroku config:set AUTH_PASSWORD=\"your_password\" Run git push heroku master . This will push the repo to the git remote at Heroku (instead of the original remote at Github), and deploy the app. Run heroku run \"POOL_SIZE=2 mix ecto.migrate\" Now, heroku open should open the frontpage of the app. Installation locally The first-time installation requires an internet connection. After it is finished, the server can be launched offline. (Note that for local deployment, the default username is default and the default password is password . You can change them in config/dev.exs .) First time installation To begin with, install Docker from https://docs.docker.com/install/ . You may have to launch the application once in order to let it install its command line tools. Verify the installation by typing docker version in a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows). Note: - Although the Docker app on Windows and Mac asks for login credentials to Docker Hub, they are not needed for local deployment. You can proceed without creating any Docker account/logging in. - Linux users would need to install docker-compose separately. See relevant instructions here . Once you have Docker installed, follow these steps: Ensure you have Git installed. Clone the server repo with git clone https://github.com/babe-project/BABE.git or git clone git@github.com:babe-project/BABE.git . Open a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows), cd into the project directory just cloned via git. For the first-time setup, run in the terminal docker volume create --name babe-app-volume -d local docker volume create --name babe-db-volume -d local docker-compose run --rm web bash -c \"mix deps.get && npm install && node node_modules/brunch/bin/brunch build && mix ecto.migrate\" Deployment After first-time installation, you can launch a local server instance which allows you to manage the experiments in your browser and stores the results. Run docker-compose up to launch the application every time you want to run the server. Wait until the line web_1 | [info] Running BABE.Endpoint with Cowboy using http://0.0.0.0:4000 appears in the terminal. Visit localhost:4000 in your browser. You should see the server up and running. Note: Windows 7 users who installed Docker Machine might need to find out the IP address used by docker-machine instead of localhost . See Docker documentation for details. Use Ctrl + C to shut down the server. Note that the database for storing experiment results is stored at /var/lib/docker/volumes/babe-db-volume/_data folder by default. As long as this folder is preserved, experiment results should persist as well.","title":"Installation"},{"location":"02_using_the_server_app/01_installation/#installation","text":"You can install _babe on a server for online use or locally on your machine. We explain here how to use Heroku as a hosting service for online use, and how to set up the server app locally.","title":"Installation"},{"location":"02_using_the_server_app/01_installation/#installation-on-heroku","text":"The _babe server app can be hosted on any hosting service or your own server. We here describe the process for installation on Heroku . Heroku makes it easy to deploy an web app without having to manually manage the infrastructure. It has a free starter tier, which should be sufficient for the purpose of running experiments. There is an official guide on how to deploy the Phoenix framework on Heroku. The deployment procedure is based on this guide, but differs in some places. {:start=\"0\"} 0. Ensure that you have the Phoenix Framework installed and working. However, if you just want to deploy this server and do no development work/change on it at all, you may skip this step. Ensure that you have a Heroku account already, and have the Heroku CLI installed and working on your computer. Ensure you have Git installed. Clone this git repo with git clone https://github.com/babe-project/BABE or git clone git@github.com:babe-project/BABE.git . cd into the project directory just cloned from your Terminal (or cmd.exe on Windows). Run heroku create --buildpack \"https://github.com/HashNuke/heroku-buildpack-elixir.git\" Run heroku buildpacks:add https://github.com/gjaldon/heroku-buildpack-phoenix-static.git (N.B.: Although the command line output tells you to run git push heroku master , don't do it yet.) You may want to change the application name instead of using the default name. In that case, run heroku apps:rename newname . Edit line 17 of the file config/prod.exs . Replace the part babe-backend.herokuapp.com after host with the app name (shown when you first ran heroku create , e.g. mysterious-meadow-6277.herokuapp.com , or the app name that you set at step 6, e.g. newname.herokuapp.com ). You shouldn't need to modify anything else. Ensure that you're at the top-level project directory. Run heroku addons:create heroku-postgresql:hobby-dev heroku config:set POOL_SIZE=18 Run mix deps.get then mix phx.gen.secret . Then run heroku config:set SECRET_KEY_BASE=\"OUTPUT\" , where OUTPUT should be the output of the mix phx.gen.secret step. Note: If you don't have the Phoenix framework installed on your computer, you may choose to use some other random generator for this task, which essentially asks for a random 64-character secret. On Mac and Linux, you may run openssl rand -base64 64 . Or you may use an online password generator such as the one offered by LastPass . Run git add config/prod.exs , then git commit -m \"Set app URL\" . Don't forget to set the environment variables AUTH_USERNAME and AUTH_PASSWORD , either in the Heroku web interface or via the command line, i.e. heroku config:set AUTH_USERNAME=\"your_username\" heroku config:set AUTH_PASSWORD=\"your_password\" Run git push heroku master . This will push the repo to the git remote at Heroku (instead of the original remote at Github), and deploy the app. Run heroku run \"POOL_SIZE=2 mix ecto.migrate\" Now, heroku open should open the frontpage of the app.","title":"Installation on Heroku"},{"location":"02_using_the_server_app/01_installation/#installation-locally","text":"The first-time installation requires an internet connection. After it is finished, the server can be launched offline. (Note that for local deployment, the default username is default and the default password is password . You can change them in config/dev.exs .)","title":"Installation locally"},{"location":"02_using_the_server_app/01_installation/#first-time-installation","text":"To begin with, install Docker from https://docs.docker.com/install/ . You may have to launch the application once in order to let it install its command line tools. Verify the installation by typing docker version in a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows). Note: - Although the Docker app on Windows and Mac asks for login credentials to Docker Hub, they are not needed for local deployment. You can proceed without creating any Docker account/logging in. - Linux users would need to install docker-compose separately. See relevant instructions here . Once you have Docker installed, follow these steps: Ensure you have Git installed. Clone the server repo with git clone https://github.com/babe-project/BABE.git or git clone git@github.com:babe-project/BABE.git . Open a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows), cd into the project directory just cloned via git. For the first-time setup, run in the terminal docker volume create --name babe-app-volume -d local docker volume create --name babe-db-volume -d local docker-compose run --rm web bash -c \"mix deps.get && npm install && node node_modules/brunch/bin/brunch build && mix ecto.migrate\"","title":"First time installation"},{"location":"02_using_the_server_app/01_installation/#deployment","text":"After first-time installation, you can launch a local server instance which allows you to manage the experiments in your browser and stores the results. Run docker-compose up to launch the application every time you want to run the server. Wait until the line web_1 | [info] Running BABE.Endpoint with Cowboy using http://0.0.0.0:4000 appears in the terminal. Visit localhost:4000 in your browser. You should see the server up and running. Note: Windows 7 users who installed Docker Machine might need to find out the IP address used by docker-machine instead of localhost . See Docker documentation for details. Use Ctrl + C to shut down the server. Note that the database for storing experiment results is stored at /var/lib/docker/volumes/babe-db-volume/_data folder by default. As long as this folder is preserved, experiment results should persist as well.","title":"Deployment"},{"location":"02_using_the_server_app/02_use/","text":"Use After installation you can visit the server app in a browser, with the username and password you previously specified. For Heroku deployment, you may do so by running heroku open in the command line or find the app URL in your Heroku account. For local deployment, the URL is by default http://localhost:4000. There is an example demo of the server app available at https://babe-demo.herokuapp.com . Managing experiments The server app shows a list of experiments whose data may be stored in a database. It shows the experiments ID, its name, its author, the number of submissions retrieved so far, date information, as well as whether the experiment is currently active or not. If an experiment is set to be active, it allows further submissions to be recorded in the database. The server app allows you to retrieve the data for an experiment from the database. Simply click on the button \"Retrieve CSV\" to download a CSV-file with the data collected so far. To delete an experiment, click the \"Delete\" button. Always make sure that you have recovered all necessary data from that experiment; otherwise your data collected so far might be irrevocably lost. You can also edit an experiment with the \"Edit\" button. You can change information about the experiment on the edit-screen. You can also toggle whether the experiment is active or not. You can set a maximum number of submissions after which the experiment automatically toggles its activity status off. Any submission made by a participant to a non-active experiment is just lost and will not be recorded. This is to protect your database from pollution or attacks, but if used unwisely could also cause you loss of relevant data. Creating new experiments Click on the \"New\" button under \"Manage Experiments\" to set up a new data base for your experiment. The interface for creating a new experiment is very similar to editing an existing experiment. Importantly, you need to give some required information about a new experiment (name and author). If you want to use dynamic retrieval of experiment data ( documentation pending ), you must specify which fields should be available to be retrieved by your API calls. This allows you to expose only the relevant fields, since the dynamic retrieval API is not password protected by default. After you have created your experiment, there are two pieces of information that are important for later use. When you specify the deploy information , you must supply the ID which the server app allocates to your experiment and you must specify the URL (possibly local) of the server app itself. You find these pieces of information when you click on \"Edit\" for your newly created experiment. You need to specify the ID in field experimentID and the server URL for submissions without the ID in the field serverAppURL . So, in the case above, you would initialize your experiment with the following information: babeInit({ ... deploy: { experimentID: \"1\", serverAppURL: \"https://babe-demo.herokuapp.com/api/submit_experiment/\", ... } ... });","title":"Use"},{"location":"02_using_the_server_app/02_use/#use","text":"After installation you can visit the server app in a browser, with the username and password you previously specified. For Heroku deployment, you may do so by running heroku open in the command line or find the app URL in your Heroku account. For local deployment, the URL is by default http://localhost:4000. There is an example demo of the server app available at https://babe-demo.herokuapp.com .","title":"Use"},{"location":"02_using_the_server_app/02_use/#managing-experiments","text":"The server app shows a list of experiments whose data may be stored in a database. It shows the experiments ID, its name, its author, the number of submissions retrieved so far, date information, as well as whether the experiment is currently active or not. If an experiment is set to be active, it allows further submissions to be recorded in the database. The server app allows you to retrieve the data for an experiment from the database. Simply click on the button \"Retrieve CSV\" to download a CSV-file with the data collected so far. To delete an experiment, click the \"Delete\" button. Always make sure that you have recovered all necessary data from that experiment; otherwise your data collected so far might be irrevocably lost. You can also edit an experiment with the \"Edit\" button. You can change information about the experiment on the edit-screen. You can also toggle whether the experiment is active or not. You can set a maximum number of submissions after which the experiment automatically toggles its activity status off. Any submission made by a participant to a non-active experiment is just lost and will not be recorded. This is to protect your database from pollution or attacks, but if used unwisely could also cause you loss of relevant data.","title":"Managing experiments"},{"location":"02_using_the_server_app/02_use/#creating-new-experiments","text":"Click on the \"New\" button under \"Manage Experiments\" to set up a new data base for your experiment. The interface for creating a new experiment is very similar to editing an existing experiment. Importantly, you need to give some required information about a new experiment (name and author). If you want to use dynamic retrieval of experiment data ( documentation pending ), you must specify which fields should be available to be retrieved by your API calls. This allows you to expose only the relevant fields, since the dynamic retrieval API is not password protected by default. After you have created your experiment, there are two pieces of information that are important for later use. When you specify the deploy information , you must supply the ID which the server app allocates to your experiment and you must specify the URL (possibly local) of the server app itself. You find these pieces of information when you click on \"Edit\" for your newly created experiment. You need to specify the ID in field experimentID and the server URL for submissions without the ID in the field serverAppURL . So, in the case above, you would initialize your experiment with the following information: babeInit({ ... deploy: { experimentID: \"1\", serverAppURL: \"https://babe-demo.herokuapp.com/api/submit_experiment/\", ... } ... });","title":"Creating new experiments"},{"location":"03_deploying_experiments/01_configuration/","text":"Deploy Configuration The deployment method determines how to ship your experiment to your participants (if at all) and how to process its data. For development, you will want to use the debug mode, which shows the data collected from the current execution of the experiment in the browser at the end of the experiment. To actually collect data from participants, _babe uses the babe server app to store the data in a data base (and possibly to manage allocation of participants to different variants of your experiment). You therefore need to have a running instance of the server app, either online or locally, as described in the server app section on installation . There are three deployment modes to collect data via the _babe server app (to be detailed below): The directLink mode allows participants to work on your experiment simply by following a link. The MTurk mode is used to recruit participants via Amazon's Mechanical Turk . The Prolific mode is used to recruit participants via Prolific . All of these methods require that you have initialized a database on the _babe server app, as described here . You need the experimentID (a running number) which the server app creates for your experiment, as well as the URL (possibly local) of your experiment. Unless you run your experiment strictly locally on your own (lab) computer(s), you also need to launch the experiment as a website on some hosting service. A possibility for doing so is described in the section on hosting on Netlify . Changing deploy information Deployment information needs to be given during the initial creation of the _babe-object (e.g., in file 06_main.js of the Departure Point ), by setting the properties of the deploy object, as shown below: babeInit({ ... deploy: { experimentID: \"INSERT_A_NUMBER\", serverAppURL: \"https://babe-demo.herokuapp.com/api/submit_experiment/\", // Possible deployment methods are: // \"debug\" and \"directLink\" // As well as \"MTurk\", \"MTurkSandbox\" and \"Prolific\" deployMethod: \"debug\", contact_email: \"YOUREMAIL@wherelifeisgreat.you\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); None of these fields matter for the debug mode. But for any of the other modes, you should specify appropriate information to the following fields: contact_email should contain an appropriate email address which will be displayed in an alert box in case of errors, so your participants can directly reach out to you. experimentID must contain the ID the _babe server app provided for your experiment when created it online (see the section on server app use for more information). serverAppURL is the URL (possibly local) to your server app instance which handles the data (see the section on server app use for more information). prolificURL needs to be specified only if you use the Prolific deploy mode. In that case you need to enter here the return URL given to you when you create your experiment on the Prolific web site (see information below).","title":"Deploy configuration"},{"location":"03_deploying_experiments/01_configuration/#deploy-configuration","text":"The deployment method determines how to ship your experiment to your participants (if at all) and how to process its data. For development, you will want to use the debug mode, which shows the data collected from the current execution of the experiment in the browser at the end of the experiment. To actually collect data from participants, _babe uses the babe server app to store the data in a data base (and possibly to manage allocation of participants to different variants of your experiment). You therefore need to have a running instance of the server app, either online or locally, as described in the server app section on installation . There are three deployment modes to collect data via the _babe server app (to be detailed below): The directLink mode allows participants to work on your experiment simply by following a link. The MTurk mode is used to recruit participants via Amazon's Mechanical Turk . The Prolific mode is used to recruit participants via Prolific . All of these methods require that you have initialized a database on the _babe server app, as described here . You need the experimentID (a running number) which the server app creates for your experiment, as well as the URL (possibly local) of your experiment. Unless you run your experiment strictly locally on your own (lab) computer(s), you also need to launch the experiment as a website on some hosting service. A possibility for doing so is described in the section on hosting on Netlify .","title":"Deploy Configuration"},{"location":"03_deploying_experiments/01_configuration/#changing-deploy-information","text":"Deployment information needs to be given during the initial creation of the _babe-object (e.g., in file 06_main.js of the Departure Point ), by setting the properties of the deploy object, as shown below: babeInit({ ... deploy: { experimentID: \"INSERT_A_NUMBER\", serverAppURL: \"https://babe-demo.herokuapp.com/api/submit_experiment/\", // Possible deployment methods are: // \"debug\" and \"directLink\" // As well as \"MTurk\", \"MTurkSandbox\" and \"Prolific\" deployMethod: \"debug\", contact_email: \"YOUREMAIL@wherelifeisgreat.you\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); None of these fields matter for the debug mode. But for any of the other modes, you should specify appropriate information to the following fields: contact_email should contain an appropriate email address which will be displayed in an alert box in case of errors, so your participants can directly reach out to you. experimentID must contain the ID the _babe server app provided for your experiment when created it online (see the section on server app use for more information). serverAppURL is the URL (possibly local) to your server app instance which handles the data (see the section on server app use for more information). prolificURL needs to be specified only if you use the Prolific deploy mode. In that case you need to enter here the return URL given to you when you create your experiment on the Prolific web site (see information below).","title":"Changing deploy information"},{"location":"03_deploying_experiments/02_recruitment_MTurk/","text":"Recruitment via MTurk You can post a _babe experiment as an external HIT on MTurk. If you are familiar with posting external HITs, the only thing that you need to take into account is that _babe experiments send their collected data to the _babe backend. So, in order to collect the data from your experiment, you would visit the _babe backend to download a CSV file. No need to go via MTurk. If you are not familiar with posting external HITs on MTurk, here is a simple method that uses boto3 , which is a Python SDK for Amazon's Web Services (AWS). The MTurkDeployTemplate gives a full example of an experiment that uses this method. The method we propose here is easy in the sense that it might require less downloading / installing than other methods. You only need Python and the boto3 package. (But here and there are fully viable alternative methods and resources that provide additional useful information.) We assume that you have an MTurk account and that you have your AWS credentials ready at hand. (If not, see here for instructions on how to setup your account.) Download a recent version of Python (we used 3.6 at the time of writing) and install the boto3 package, e.g., using pip . Next, in your homedirectory, create the file: ~/.aws/config Fill this file with the following content, so that boto3 knows about your AWS credentials (never post this, host this or share this): [default] aws_access_key_id=YOUR_ACCESS_KEY_ID aws_secret_access_key=YOUR_SECRET_ACCESS_KEY Make sure that your _babe experiment is ready for MTurk deployment: set the deployment method to MTurk host the experiment on a web server, e.g., using Netlify make sure you have the URL for your web-version of the experiment ready Save the following code in a file called create_HIT.py , after inserting the correct URL to your experiment and commenting in/out the relevant lines depending on whether you want a real live experiment or a test version in the sandbox. import boto3 MTURK_SANDBOX = 'https://mturk-requester-sandbox.us-east-1.amazonaws.com' mturk = boto3.client('mturk', region_name='us-east-1' # endpoint_url = MTURK_SANDBOX # include this for sandbox mode ) your_url = \"https://YOUR_URL\" # insert your URL external_question = \"\"\"<ExternalQuestion xmlns='http://mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2006-07-14/ExternalQuestion.xsd'> <ExternalURL>\"\"\" + your_url + \"\"\"</ExternalURL> <FrameHeight>600</FrameHeight> </ExternalQuestion>\"\"\" new_hit = mturk.create_hit( Title = 'Your title', Description = 'Your description', Keywords = 'some keywords', Reward = '0.5', # how much to pay MaxAssignments = 1, # how many participants LifetimeInSeconds = 172800, AssignmentDurationInSeconds = 600, AutoApprovalDelayInSeconds = 14400, Question = external_question, ) print(\"A new HIT has been created. You can preview it here:\") #print(\"https://workersandbox.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # comment in for sandbox mode print(\"https://worker.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # use this otherwise print(\"HITID = \" + new_hit['HIT']['HITId'] + \" (for your reference)\") Now execute python create_HIT.py . Make sure you note the HITid that this call returns, because you need it to further identify this experimental run when interacting with MTurk. Download file get_HIT_status.py here and use python get_HIT_status.py YOUR_HIT_ID , where YOUR_HIT_ID is the HITid returned when you posted the HIT, to learn how many workers have completed your work. Download file approve_HIT.py here and use python approve_HIT.py YOUR_HIT_ID to reimburse all workers. You can manipulate (expire, extend, ...) your HIT using boto3 as described in the boto3 documentation . For some recurrent manipulations, you can also use this web interface .","title":"Recruitment via MTurk"},{"location":"03_deploying_experiments/02_recruitment_MTurk/#recruitment-via-mturk","text":"You can post a _babe experiment as an external HIT on MTurk. If you are familiar with posting external HITs, the only thing that you need to take into account is that _babe experiments send their collected data to the _babe backend. So, in order to collect the data from your experiment, you would visit the _babe backend to download a CSV file. No need to go via MTurk. If you are not familiar with posting external HITs on MTurk, here is a simple method that uses boto3 , which is a Python SDK for Amazon's Web Services (AWS). The MTurkDeployTemplate gives a full example of an experiment that uses this method. The method we propose here is easy in the sense that it might require less downloading / installing than other methods. You only need Python and the boto3 package. (But here and there are fully viable alternative methods and resources that provide additional useful information.) We assume that you have an MTurk account and that you have your AWS credentials ready at hand. (If not, see here for instructions on how to setup your account.) Download a recent version of Python (we used 3.6 at the time of writing) and install the boto3 package, e.g., using pip . Next, in your homedirectory, create the file: ~/.aws/config Fill this file with the following content, so that boto3 knows about your AWS credentials (never post this, host this or share this): [default] aws_access_key_id=YOUR_ACCESS_KEY_ID aws_secret_access_key=YOUR_SECRET_ACCESS_KEY Make sure that your _babe experiment is ready for MTurk deployment: set the deployment method to MTurk host the experiment on a web server, e.g., using Netlify make sure you have the URL for your web-version of the experiment ready Save the following code in a file called create_HIT.py , after inserting the correct URL to your experiment and commenting in/out the relevant lines depending on whether you want a real live experiment or a test version in the sandbox. import boto3 MTURK_SANDBOX = 'https://mturk-requester-sandbox.us-east-1.amazonaws.com' mturk = boto3.client('mturk', region_name='us-east-1' # endpoint_url = MTURK_SANDBOX # include this for sandbox mode ) your_url = \"https://YOUR_URL\" # insert your URL external_question = \"\"\"<ExternalQuestion xmlns='http://mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2006-07-14/ExternalQuestion.xsd'> <ExternalURL>\"\"\" + your_url + \"\"\"</ExternalURL> <FrameHeight>600</FrameHeight> </ExternalQuestion>\"\"\" new_hit = mturk.create_hit( Title = 'Your title', Description = 'Your description', Keywords = 'some keywords', Reward = '0.5', # how much to pay MaxAssignments = 1, # how many participants LifetimeInSeconds = 172800, AssignmentDurationInSeconds = 600, AutoApprovalDelayInSeconds = 14400, Question = external_question, ) print(\"A new HIT has been created. You can preview it here:\") #print(\"https://workersandbox.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # comment in for sandbox mode print(\"https://worker.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # use this otherwise print(\"HITID = \" + new_hit['HIT']['HITId'] + \" (for your reference)\") Now execute python create_HIT.py . Make sure you note the HITid that this call returns, because you need it to further identify this experimental run when interacting with MTurk. Download file get_HIT_status.py here and use python get_HIT_status.py YOUR_HIT_ID , where YOUR_HIT_ID is the HITid returned when you posted the HIT, to learn how many workers have completed your work. Download file approve_HIT.py here and use python approve_HIT.py YOUR_HIT_ID to reimburse all workers. You can manipulate (expire, extend, ...) your HIT using boto3 as described in the boto3 documentation . For some recurrent manipulations, you can also use this web interface .","title":"Recruitment via MTurk"},{"location":"03_deploying_experiments/03_recruitment_Prolific/","text":"Recruitment via Prolific The following assumes that you are familiar with how to operate experiments with Prolific . Go to the Prolific website and create a new experiment. Make a note of the completion URL that is provided by Prolific. Enter the completion URL in the field prolificURL when creating your experiment, as follows: babeInit({ ... deploy: { deployMethod: \"Prolific\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); Use deploy method Prolific has two consequences. For one, it will insert a text input field in the introduction view of your experiment. For another, it will supply a confirm button at the end of the experiment, which takes participants to the Prolific website where they are supplied with their completion code. The data from your experiment will not be stored by Prolific, but recorded by the _babe server app. Before launching the study on Prolific, double-check that the database on the back end is set up and the necessary information ( experimentID , server URL) are set. Also do not forget to update a web-site version of your experiment so that it includes the correct information in prolificURL before running the study.","title":"Recruitment via Prolific"},{"location":"03_deploying_experiments/03_recruitment_Prolific/#recruitment-via-prolific","text":"The following assumes that you are familiar with how to operate experiments with Prolific . Go to the Prolific website and create a new experiment. Make a note of the completion URL that is provided by Prolific. Enter the completion URL in the field prolificURL when creating your experiment, as follows: babeInit({ ... deploy: { deployMethod: \"Prolific\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); Use deploy method Prolific has two consequences. For one, it will insert a text input field in the introduction view of your experiment. For another, it will supply a confirm button at the end of the experiment, which takes participants to the Prolific website where they are supplied with their completion code. The data from your experiment will not be stored by Prolific, but recorded by the _babe server app. Before launching the study on Prolific, double-check that the database on the back end is set up and the necessary information ( experimentID , server URL) are set. Also do not forget to update a web-site version of your experiment so that it includes the correct information in prolificURL before running the study.","title":"Recruitment via Prolific"},{"location":"03_deploying_experiments/04_hosting_on_netlify/","text":"Hosting on Netlify Registration Go to https://www.netlify.com/ and sign up using GitHub Deployment Using git: Click on the New site from Git -Button, choose GitHub and authorize the netlify-app on GitHub, configure which repositories to give access to, (back on netlify) select the repository to deploy, enter the build command rm -rf dist && mkdir dist && rsync -rv * dist --exclude ./dist and the publish directory dist (this is a workaround for publishing node_modules , see here , another way of bundling the files may be appropriate), click on Deploy site Manual: Go to https://app.netlify.com/ and drag and drop your finished experiment folder (including node_modules) to the drag&drop area Configuration Change the domain name: Click on the deployed site you want to configure, click on Domain setting , click on Edit site name and change to the name of choice.","title":"Hosting on netlify"},{"location":"03_deploying_experiments/04_hosting_on_netlify/#hosting-on-netlify","text":"Registration Go to https://www.netlify.com/ and sign up using GitHub Deployment Using git: Click on the New site from Git -Button, choose GitHub and authorize the netlify-app on GitHub, configure which repositories to give access to, (back on netlify) select the repository to deploy, enter the build command rm -rf dist && mkdir dist && rsync -rv * dist --exclude ./dist and the publish directory dist (this is a workaround for publishing node_modules , see here , another way of bundling the files may be appropriate), click on Deploy site Manual: Go to https://app.netlify.com/ and drag and drop your finished experiment folder (including node_modules) to the drag&drop area Configuration Change the domain name: Click on the deployed site you want to configure, click on Domain setting , click on Edit site name and change to the name of choice.","title":"Hosting on Netlify"}]}