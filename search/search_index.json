{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"_magpie: minimal architecture for the generation of portable interactive experiments A quick start guide can be found here .","title":"_magpie: minimal architecture for the generation of portable interactive experiments"},{"location":"#_magpie-minimal-architecture-for-the-generation-of-portable-interactive-experiments","text":"A quick start guide can be found here .","title":"_magpie: minimal architecture for the generation of portable interactive experiments"},{"location":"04_development/","text":"Development To get the development version of the _magpie package, clone this repository and install the dependencies by running npm install in the terminal. Workflow branches: master - Current stable version. development - Development version. This is where new featues or bug fixes are pushed. When the version is stable, the branch is merged into master. (1) Source files src/ magpie-canvas.js magpie-errors.js magpie-init.js magpie-progress-bar.js magpie-submit.js magpie-utils.js magpie-views.js magpie.css (2) Create magpie.js and magpie.full.js Option 1: Build the _magpie package files while developing Use npm run watch command from the magpie-ea folder to start a process which watches for changes in the files in src and builds (updates) magpie.js and magpie.full.js . This commands builds both magpie.js and magpie.full.js when a file in src is saved. Option 2: Make changes to the files and then build the _magpie files Run npm run concat from the magpie-ea folder. This command builds both magpie.js and magpie.full.js . (3) Merge into master include a changelog information in the README merge to master update the version of _magpie in package.json (4) Publish to npm Run npm publish from the magpie-ea folder to publish the new version of _magpie.","title":"Development"},{"location":"04_development/#development","text":"To get the development version of the _magpie package, clone this repository and install the dependencies by running npm install in the terminal.","title":"Development"},{"location":"04_development/#workflow","text":"branches: master - Current stable version. development - Development version. This is where new featues or bug fixes are pushed. When the version is stable, the branch is merged into master.","title":"Workflow"},{"location":"04_development/#1-source-files","text":"src/ magpie-canvas.js magpie-errors.js magpie-init.js magpie-progress-bar.js magpie-submit.js magpie-utils.js magpie-views.js magpie.css","title":"(1) Source files"},{"location":"04_development/#2-create-magpiejs-and-magpiefulljs","text":"","title":"(2) Create magpie.js and magpie.full.js"},{"location":"04_development/#option-1-build-the-95magpie-package-files-while-developing","text":"Use npm run watch command from the magpie-ea folder to start a process which watches for changes in the files in src and builds (updates) magpie.js and magpie.full.js . This commands builds both magpie.js and magpie.full.js when a file in src is saved.","title":"Option 1: Build the _magpie package files while developing"},{"location":"04_development/#option-2-make-changes-to-the-files-and-then-build-the-95magpie-files","text":"Run npm run concat from the magpie-ea folder. This command builds both magpie.js and magpie.full.js .","title":"Option 2: Make changes to the files and then build the _magpie files"},{"location":"04_development/#3-merge-into-master","text":"include a changelog information in the README merge to master update the version of _magpie in package.json","title":"(3) Merge into master"},{"location":"04_development/#4-publish-to-npm","text":"Run npm publish from the magpie-ea folder to publish the new version of _magpie.","title":"(4) Publish to npm"},{"location":"05_about/","text":"_magpie has been developed for open science by open scientists: Stela Ilieva Xiang Ji Jannis Rautenstrauch Michael Franke _magpie has been supported financially by the Priority Program XPrag.de (DFG Schwerpunktprogramm 1727) and the SFB 833 Constitution of Meaning . We encourage your participation. Please raise an issue on GitHub when you have reason to. Also, please submit your own experiments to complete the list of templates.","title":"About"},{"location":"01_designing_experiments/01_template_views/","text":"Template views Wrapping views Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. All wrapping views have two obligatory fields : trials: int the number of trials this view will be cycled through name: string the unique name of this view instance Intro view Instantiate with magpieViews.view_generator('intro', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default The intro view uses the following predefined view elements : stimulus_container_generator: fixed text answer_container_generator: one_button handle_response_function: intro Instructions view Instantiate with magpieViews.view_generator('instructions', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default The intro view uses the following predefined view elements : stimulus_container_generator: fixed text answer_container_generator: one_button handle_response_function: one_click Begin view Instantiate with magpieViews.view_generator('begin, ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default The begin view uses the following predefined view elements : stimulus_container_generator: fixed text answer_container_generator: one_button handle_response_function: one_click Post_test view Instantiate with magpieViews.view_generator('post_test', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)' The post test view uses the following predefined view elements : stimulus_container_generator: post_test answer_container_generator: post_test handle_response_function: post_test Thanks view Instantiate with magpieViews.view_generator('thanks', ...) . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific' The thanks view uses the following predefined view elements : stimulus_container_generator: empty answer_container_generator: empty handle_response_function: thanks Trial views Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int the number of trials this view will appear name: string the name of the view data: array list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below. Forced choice (2 alternatives) Instantiate with magpieViews.view_generator('forced_choice', ...) Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ]; The forced_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: button_choice handle_response_function: button_choice Sentence choice Instantiate with magpieViews.view_generator('sentence_choice', ...) . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; The sentence_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: sentence_choice handle_response_function: button_choice Image selection Instantiate with magpieViews.view_generator('image_seletion', ...) . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about magpie canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ]; The image_selection view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: image_selection handle_response_function: button_choice Textbox Input task Instantiate with magpieViews.view_generator('textbox_input', ...) . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like? like?\", min_chars: 50 } ]; The forced_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: textbox_input handle_response_function: textbox_input Slider rating Instantiate with magpieViews.view_generator('slider_rating', ...) . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like? like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ]; The slider_rating view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: slider_rating handle_response_function: slider_rating Dropdown choice Instantiate with magpieViews.view_generator(drowdown_choice', ...) . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; The dropdown_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: dropdown_choice handle_response_function: dropdown_choice Rating scale Instantiate with magpieViews.view_generator('rating_scale', ...) . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; The rating_scale view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: rating_scale handle_response_function: button_choice Key press Instantiate with magpieViews.view_generator('key_press', ...) . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about magpie canvas Sample data const key_press_trials = [ { question: \"What's the weather like? like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ]; The key_press view uses the following predefined view elements : stimulus_container_generator: key_press answer_container_generator: question handle_response_function: key_press Self-paced reading There are templates for realizing self-paced reading tasks too. Self-paced reading with forced choice response Instantiate with magpieViews.view_generator('self_paced_reading', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about magpie canvas question: string wordPos: \"next\" or \"same\" option how to display the spr parts, if \"next\" every spr part is displayed next to each other, as in a sentence, if \"same\" every spr part is displayed at the same place default: \"next\" underline: \"words\", \"sentence\" or \"none\" option how to underline the spr parts, if \"words\" every part is underlined separately, if \"sentence\" the complete sentence is underlined, if \"none\" there is no underline default: \"words\" Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", wordPos: \"same\" }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\", underline: \"none\" } ]; The self_paced_reading view uses the following predefined view elements : stimulus_container_generator: self_paced_reading answer_container_generator: button_choice handle_response_function: self_paced_reading Self-paced reading task with rating scale response Instantiate with magpieViews.view_generator('self_paced_reading_rating_scale', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about magpie canvas question: string wordPos: \"next\" or \"same\" option how to display the spr parts, if \"next\" every spr part is displayed next to each other, as in a sentence, if \"same\" every spr part is displayed at the same place default: \"next\" underline: \"words\", \"sentence\" or \"none\" option how to underline the spr parts, if \"words\" every part is underlined separately, if \"sentence\" the complete sentence is underlined, if \"none\" there is no underline default: \"words\" const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ]; The self_paced_reading_rating_scale view uses the following predefined view elements : stimulus_container_generator: self_paced_reading answer_container_generator: rating_choice handle_response_function: self_paced_reading","title":"Template views"},{"location":"01_designing_experiments/01_template_views/#template-views","text":"","title":"Template views"},{"location":"01_designing_experiments/01_template_views/#wrapping-views","text":"Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. All wrapping views have two obligatory fields : trials: int the number of trials this view will be cycled through name: string the unique name of this view instance","title":"Wrapping views"},{"location":"01_designing_experiments/01_template_views/#intro-view","text":"Instantiate with magpieViews.view_generator('intro', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default The intro view uses the following predefined view elements : stimulus_container_generator: fixed text answer_container_generator: one_button handle_response_function: intro","title":"Intro view"},{"location":"01_designing_experiments/01_template_views/#instructions-view","text":"Instantiate with magpieViews.view_generator('instructions', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default The intro view uses the following predefined view elements : stimulus_container_generator: fixed text answer_container_generator: one_button handle_response_function: one_click","title":"Instructions view"},{"location":"01_designing_experiments/01_template_views/#begin-view","text":"Instantiate with magpieViews.view_generator('begin, ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default The begin view uses the following predefined view elements : stimulus_container_generator: fixed text answer_container_generator: one_button handle_response_function: one_click","title":"Begin view"},{"location":"01_designing_experiments/01_template_views/#post_test-view","text":"Instantiate with magpieViews.view_generator('post_test', ...) . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)' The post test view uses the following predefined view elements : stimulus_container_generator: post_test answer_container_generator: post_test handle_response_function: post_test","title":"Post_test view"},{"location":"01_designing_experiments/01_template_views/#thanks-view","text":"Instantiate with magpieViews.view_generator('thanks', ...) . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific' The thanks view uses the following predefined view elements : stimulus_container_generator: empty answer_container_generator: empty handle_response_function: thanks","title":"Thanks view"},{"location":"01_designing_experiments/01_template_views/#trial-views","text":"Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int the number of trials this view will appear name: string the name of the view data: array list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below.","title":"Trial views"},{"location":"01_designing_experiments/01_template_views/#forced-choice-2-alternatives","text":"Instantiate with magpieViews.view_generator('forced_choice', ...) Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ]; The forced_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: button_choice handle_response_function: button_choice","title":"Forced choice (2 alternatives)"},{"location":"01_designing_experiments/01_template_views/#sentence-choice","text":"Instantiate with magpieViews.view_generator('sentence_choice', ...) . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; The sentence_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: sentence_choice handle_response_function: button_choice","title":"Sentence choice"},{"location":"01_designing_experiments/01_template_views/#image-selection","text":"Instantiate with magpieViews.view_generator('image_seletion', ...) . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about magpie canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ]; The image_selection view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: image_selection handle_response_function: button_choice","title":"Image selection"},{"location":"01_designing_experiments/01_template_views/#textbox-input-task","text":"Instantiate with magpieViews.view_generator('textbox_input', ...) . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like? like?\", min_chars: 50 } ]; The forced_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: textbox_input handle_response_function: textbox_input","title":"Textbox Input task"},{"location":"01_designing_experiments/01_template_views/#slider-rating","text":"Instantiate with magpieViews.view_generator('slider_rating', ...) . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like? like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ]; The slider_rating view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: slider_rating handle_response_function: slider_rating","title":"Slider rating"},{"location":"01_designing_experiments/01_template_views/#dropdown-choice","text":"Instantiate with magpieViews.view_generator(drowdown_choice', ...) . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; The dropdown_choice view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: dropdown_choice handle_response_function: dropdown_choice","title":"Dropdown choice"},{"location":"01_designing_experiments/01_template_views/#rating-scale","text":"Instantiate with magpieViews.view_generator('rating_scale', ...) . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; The rating_scale view uses the following predefined view elements : stimulus_container_generator: basic_stimulus answer_container_generator: rating_scale handle_response_function: button_choice","title":"Rating scale"},{"location":"01_designing_experiments/01_template_views/#key-press","text":"Instantiate with magpieViews.view_generator('key_press', ...) . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about magpie canvas Sample data const key_press_trials = [ { question: \"What's the weather like? like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ]; The key_press view uses the following predefined view elements : stimulus_container_generator: key_press answer_container_generator: question handle_response_function: key_press","title":"Key press"},{"location":"01_designing_experiments/01_template_views/#self-paced-reading","text":"There are templates for realizing self-paced reading tasks too.","title":"Self-paced reading"},{"location":"01_designing_experiments/01_template_views/#self-paced-reading-with-forced-choice-response","text":"Instantiate with magpieViews.view_generator('self_paced_reading', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about magpie canvas question: string wordPos: \"next\" or \"same\" option how to display the spr parts, if \"next\" every spr part is displayed next to each other, as in a sentence, if \"same\" every spr part is displayed at the same place default: \"next\" underline: \"words\", \"sentence\" or \"none\" option how to underline the spr parts, if \"words\" every part is underlined separately, if \"sentence\" the complete sentence is underlined, if \"none\" there is no underline default: \"words\" Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", wordPos: \"same\" }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\", underline: \"none\" } ]; The self_paced_reading view uses the following predefined view elements : stimulus_container_generator: self_paced_reading answer_container_generator: button_choice handle_response_function: self_paced_reading","title":"Self-paced reading with forced choice response"},{"location":"01_designing_experiments/01_template_views/#self-paced-reading-task-with-rating-scale-response","text":"Instantiate with magpieViews.view_generator('self_paced_reading_rating_scale', ...) . Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about magpie canvas question: string wordPos: \"next\" or \"same\" option how to display the spr parts, if \"next\" every spr part is displayed next to each other, as in a sentence, if \"same\" every spr part is displayed at the same place default: \"next\" underline: \"words\", \"sentence\" or \"none\" option how to underline the spr parts, if \"words\" every part is underlined separately, if \"sentence\" the complete sentence is underlined, if \"none\" there is no underline default: \"words\" const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ]; The self_paced_reading_rating_scale view uses the following predefined view elements : stimulus_container_generator: self_paced_reading answer_container_generator: rating_choice handle_response_function: self_paced_reading","title":"Self-paced reading task with rating scale response"},{"location":"01_designing_experiments/01_views/","text":"... coming soon ... general information about the design of a _magpie experiment There are two types of views: trial type and wrapping views. _magpie provides a number of templates to create views with a pre-given structure.","title":"01 views"},{"location":"01_designing_experiments/02_template_views/","text":"","title":"02 template views"},{"location":"01_designing_experiments/02a_wrapping_views/","text":"Wrapping views Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Intro view Instantiate with magpieViews.intro . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default Instructions view Instantiate with magpieViews.instructions . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default Begin view Instantiate with magpieViews.begin . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default PostTest view Instantiate with magpieViews.postTest . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)' Thanks view Instantiate with magpieViews.thanks . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific'","title":"Wrapping views"},{"location":"01_designing_experiments/02a_wrapping_views/#wrapping-views","text":"Wrapping views are short, usually one-trial views that structure your experiment. They can provide a welcome message, instructions or collect post-survey data. The most important wrapping view is the thanks view. The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment.","title":"Wrapping views"},{"location":"01_designing_experiments/02a_wrapping_views/#intro-view","text":"Instantiate with magpieViews.intro . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Welcome!' text: string the text of the view default: there is no default","title":"Intro view"},{"location":"01_designing_experiments/02a_wrapping_views/#instructions-view","text":"Instantiate with magpieViews.instructions . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Instructions' text: string the text of the view default: there is no default","title":"Instructions view"},{"location":"01_designing_experiments/02a_wrapping_views/#begin-view","text":"Instantiate with magpieViews.begin . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Begin' text: string the text of the view default: there is no default","title":"Begin view"},{"location":"01_designing_experiments/02a_wrapping_views/#posttest-view","text":"Instantiate with magpieViews.postTest . Optional fields: buttonText: string the text of the button that takes the participant to the next view default: 'Next' title: string the title of the view default: 'Additional Information' text: string the text of the view default: there is no default age_question: string question about participant's age default: 'Age', gender_question: string question about participant's gender default: 'Gender' gender_male: string answer option for the gender question default: 'male' gender_female: string answer option for the gender question default: 'female' gender_other: string answer option for the gender question default: 'other' edu_question: string question about participant's level of education default: 'Level of Education' edu_graduated_high_school: string answer option for the education question default: 'Graduated High School' edu_graduated_college: string answer option for the education question default: 'Graduated College' edu_higher_degree: string answer option for the education question default: 'Higher Degree' languages_question: string question about participant's native languages default: 'Native Languages' languages_more: string more info about what native languages are default: '(i.e. the language(s) spoken at home when you were a child)'","title":"PostTest view"},{"location":"01_designing_experiments/02a_wrapping_views/#thanks-view","text":"Instantiate with magpieViews.thanks . The thanks view must always be included in your experiment because it wraps up and processes the data collected during the experiment. Optional fields: title: string the title of the view default: 'Thank you for taking part in this experiment!' prolificConfirmText: string text asking the participant to press the 'confirm' button default: 'Please press the button below to confirm that you completed the experiment with Prolific'","title":"Thanks view"},{"location":"01_designing_experiments/02b_trial_views/","text":"Trial views Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int - the number of trials this view will appear name: string - the name of the view data: array - list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below. Forced-choice task Instantiate with magpieView.forcedChoice . Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ]; Sentence Choice task Instantiate with magpieViews.sentenceChoice . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Image Selection task Instantiate with magpieViews.imageSelection . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about magpie canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ]; Textbox Input task Instantiate with magpieViews.textboxInput . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like?\", min_chars: 50 } ]; Slider Rating task Instantiate with magpieViews.sliderRating . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ]; Dropdown Choice task Instantiate with magpieViews.dropdownChoice . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Rating Scale task Instantiate with magpieViews.ratingScale . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ]; Key Press task Instantiate with magpieViews.keyPress . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about magpie canvas Sample data const key_press_trials = [ { question: \"What's the weather like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ];","title":"Trial views"},{"location":"01_designing_experiments/02b_trial_views/#trial-views","text":"Trial views are the parts of your experiment which are (usually) instantiated several times (realizing different trials of your, say, main experimental task). They usually collect the data and often rely on additional information (e.g., the picture to be displayed in trial 27, or the question and answer options for trial 13). All trial views have three obligatory fields : trials: int - the number of trials this view will appear name: string - the name of the view data: array - list of objects, each with information for each consecutive trial Different types of wrapping views have more optional fields, as documented below.","title":"Trial views"},{"location":"01_designing_experiments/02b_trial_views/#forced-choice-task","text":"Instantiate with magpieView.forcedChoice . Displays a context, a picture and a question to be answered in a two-alternative forced choice task. Choices are made by clicking on one of two buttons. Obligatory Fields option1: string - text on button for option 1 option2: string - text on button for option 2 Optional Fields question: string - question to be asked QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed Sample data const forced_choice_trials = [ { picture: \"path/to/picture_of_questionmark.jpg\", question: \"What's the weather like? like?\", option1: \"shiny\", option2: \"rainbow\" } ];","title":"Forced-choice task"},{"location":"01_designing_experiments/02b_trial_views/#sentence-choice-task","text":"Instantiate with magpieViews.sentenceChoice . Similar to the forcedChoice view, this view presents two text-based options to click on. This view, however, realizes options on longer buttons arranged vertically. This is better for choice between several longer expressions, like whole sentences. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const sentence_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { picture: 'path/to/picture_of_bread.jpg', option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Sentence Choice task"},{"location":"01_designing_experiments/02b_trial_views/#image-selection-task","text":"Instantiate with magpieViews.imageSelection . Realizes another 2-alternative forced choice task, by presenting two pictures (arranged horizontally) and requiring a click on one of the pictures. Obligatory Fields option1: string - label for choice of picture 1 (stored in response variable) option2: string - label for choice of picture 2 (stored in response variable) picture1: string (link) - refers to option1 picture2: string (link) - refers to option2 Optional Fields QUD: string - text that is always present on the slide question: string canvas: object - more about magpie canvas Sample data const image_selection_trials = [ { picture1: 'path/to/picture1.jpg', picture2: 'path/to/picture2.jpg', option1: 'yes', option2: 'no' }, { picture1: 'path/to/picture_of_bread1.jpg', picture2: 'path/to/picture_of_bread2.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' } ];","title":"Image Selection task"},{"location":"01_designing_experiments/02b_trial_views/#textbox-input-task","text":"Instantiate with magpieViews.textboxInput . Requires users to type in text freely in a textbox. Allows to specify a minimum number of characters before the next button appears. Obligatory Fields question: string - question to answer Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) - picture to be displayed min_chars: number the minumum number of characters in the textarea field before the next button appears default - 10 Sample data const textbox_input_trials = [ { picture: \"path/to/picture.jpg\", question: \"How are you today?\", min_chars: 100 }, { question: \"What's the weather like?\", min_chars: 50 } ];","title":"Textbox Input task"},{"location":"01_designing_experiments/02b_trial_views/#slider-rating-task","text":"Instantiate with magpieViews.sliderRating . Gives you a single (horizontally oriented) slider, with endpoints whose labels can be specified. The next button only appears when the slider is clicked on or moved at least once. Internally slider values are represented as ranging from 0 to 100 in steps of 1. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const slider_rating_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", optionLeft: 'jam', optionRight: 'ham' }, { question: \"What's the weather like?\", optionLeft: 'shiny', optionRight: 'rainbow' } ];","title":"Slider Rating task"},{"location":"01_designing_experiments/02b_trial_views/#dropdown-choice-task","text":"Instantiate with magpieViews.dropdownChoice . Prompts the user to select one option from a drop-down menu, which can be embedded into a sentence, e.g., to fill in a word or phrase in a fixed sentence frame. Obligatory Fields option1: string option2: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question_left_part: string question_right_part: string Sample data const dropdown_choice_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Dropdown Choice task"},{"location":"01_designing_experiments/02b_trial_views/#rating-scale-task","text":"Instantiate with magpieViews.ratingScale . Realizes a Likert-scale (ordinal) rating task, with button labeled with consecutive numbers. Participants click on these numbered buttons to proceed. Allows labels for endpoints on the scale. Obligatory Fields optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide canvas: object - more about magpie canvas picture: string (link) question: string Sample data const rating_scale_trials = [ { picture: 'path/to/picture_of_bread.jpg', question: \"What's on the bread?\", option1: 'jam', option2: 'ham' }, { question: \"What's the weather like?\", option1: 'shiny', option2: 'rainbow' } ];","title":"Rating Scale task"},{"location":"01_designing_experiments/02b_trial_views/#key-press-task","text":"Instantiate with magpieViews.keyPress . Offers a 2-alternative forced choice task where choice options are given by pressing keys on the keyboard. Ideal for more accurate reaction time measurements. Obligatory Fields key1: string - single character string specifying which key to use for option 1 key2: string - single character string specifying which key to use for option 2 <key-specified in key1, e.g. f>: string - option 1 corresponding to first key <key specified in key2, e.g. j>: string - option 2 corresponding to second key expected: string - which option is the correct or expected one Optional Fields question: string picture: string (link) canvas: object - more about magpie canvas Sample data const key_press_trials = [ { question: \"What's the weather like?\", key1: 'f', key2: 'j', f: 'shiny', j: 'rainbow', expected: 'shiny' }, { question: \"What's on the bread?\", picture: 'path/to/picture.jpg', key1: 'f', key2: 'j', f: 'ham', j: 'jam', expected: 'jam' } ];","title":"Key Press task"},{"location":"01_designing_experiments/02c_SPR/","text":"Self-paced reading There are templates for realizing self-paced reading tasks too. Self-paced reading with forced choice response Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about magpie canvas question: string Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\" } ]; Self-paced reading task with rating scale response Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about magpie canvas question: string const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ];","title":"Self-paced reading"},{"location":"01_designing_experiments/02c_SPR/#self-paced-reading","text":"There are templates for realizing self-paced reading tasks too.","title":"Self-paced reading"},{"location":"01_designing_experiments/02c_SPR/#self-paced-reading-with-forced-choice-response","text":"Obligatory Fields sentence: string the spr parts are separated by ' | ' option1: string option2: string Optional Fields QUD: string - text that is always present on the slide help_text: string instructions to press SPACE above the spr sentence lines default - Press the SPACE bar to reveal the words picture: string canvas: object - more about magpie canvas question: string Sample data const spr_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'just press SPACE', question: \"Should you bring Johnny this box or not?\", sentence: \"all | of | the | yellow | marbles | are | inside | the | case.'\", option1: \"Bring it\", option2: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", option1: \"Bring it\", option2: \"Leave it\" } ];","title":"Self-paced reading with forced choice response"},{"location":"01_designing_experiments/02c_SPR/#self-paced-reading-task-with-rating-scale-response","text":"Obligatory Fields sentence: string the spr parts are separated by ' | ' optionLeft: string optionRight: string Optional Fields QUD: string - text that is always present on the slide help_text: string - SPACE press text above the spr sentence picture: string canvas: object - more about magpie canvas question: string const spr_rc_trials = [ { QUD: \"Johnny says: 'I want you to bring me the box where ...\", picture: \"images/all-false3.png\" help_text: 'SPACEEEE', sentence: \"all | of the | yellow marbles | are | inside | the case.'\", question: \"Should you bring Johnny this box or not?\", optionLeft: \"Bring it\", optionRight: \"Leave it\", }, { question: \"Should you bring Johnny this box or not?\", sentence: \"some | of the | black marbles | are | inside | the case.'\", optionLeft: \"Bring it\", optionRight: \"Leave it\" } ];","title":"Self-paced reading task with rating scale response"},{"location":"01_designing_experiments/03_custom_views/","text":"Custom views When the template views are not enough for your purposes, you can define your own custom views. There are two ways of doing this. The first possibility is to customize the template views . You would then keep the basic structure and design of a template view and change selected parts of it. Since all predefined template views consist of modular predefined view elements , you can often modularly assemble and tweak your desired view functionality based on slight changes of the template views. The other, more radical method is to define a completely new view from scratch . Customizing template views Each template view consists of three elements, which jointly define its appearance and functionality: stimulus container : defines the top part of the screen, containing stuff like title, the QUD, the stimulus to be shown etc. answer container : defines the lower part of the screen, containing the answer options, 'next' buttons, etc. handle response function : function that is called to handle the response Each one of these elements is independently customizable. Indeed, when a template view is created by _magpie \"behind the scenes\", it simply uses defaults for these three elements which are appropriate for the template view to be created. For example, we would normally create a template forced_choice view like so: const forced_choice_instance = magpieViews.view_generator( 'forced_choice', // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice } ); Equivalently, we could write this: const forced_choice_instance = magpieViews.view_generator( 'forced_choice', // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice }, // custom generator functions { stimulus_container_generator: stimulus_container_generators.basic_stimulus, answer_container_generator: answer_container_generators.button_choice, handle_response_function: handle_response_functions.button_choice } ); Here, we supply a third object with custom generator functions, one for each of the three elements. Since the second code box just uses the defaults which are implicit in the first, the two calls are equivalent. The description of template views lists which view elements each template view uses. All predefined view elements are listed and shown below . The stimulus generator function used by the template forced_choice view is this: function (config, CT) { return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-view-question magpie-view-qud'>${config.data[CT].QUD}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> </div>`; Generally, the function supplied to stimulus_container_generator must take the config object and a CT argument. The latter is the current trial, and it is supplied by _magpie internally. The function should then return HTML code as a string, which governs the appearance of the upper part of the view screen. You can use information from config and CT , so that when we write ${config.data[CT].QUD} in the HTML string to be returned this is replaced by the QUD information stored in config for the current trial. Notice that the picture element is inserted automatically by _magpie in the magpie-view-stimulus container. We can specify whatever we'd like to appear in the stimulus container. For example, let's insert the same picture twice. This can be done by instantiating a customized template view like so: const forced_choice_customized = magpieViews.view_generator( \"forced_choice\", // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice }, // custom generator functions { stimulus_container_generator: function (config, CT) { return `<div class='magpie-view'> <div class='magpie-view-stimulus-container'> <img src=\"${config.data[CT].picture}\" height=\"42\" width=\"42\"> <img src=\"${config.data[CT].picture}\" height=\"42\" width=\"42\"> </div> </div>`;} } ); We can also change the design and behavior of the part of the view that deals with the response. Per default, the forced_choice view uses a predefined function button_choice to have the user select one of two buttons. Suppose we wanted to have a third button. We could then use code like the following (which only works, if we define option3 in 04_trials.js as well, of course): const forced_choice_customized = magpieViews.view_generator( \"forced_choice\", // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice }, // custom generator functions { answer_container_generator: function (config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for='o1' class='magpie-response-buttons'>${config.data[CT].option1}</label> <input type='radio' name='answer' id='o1' value=${config.data[CT].option1} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].option2}</label> <input type='radio' name='answer' id='o2' value=${config.data[CT].option2} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].option3}</label> <input type='radio' name='answer' id='o3' value=${config.data[CT].option3} /> </div>`; } } ); If we want to have more than one answer within the same view, we can of course also do so. There are only a few things which we have to keep in mind. The id of each input has to be unique, so we have to make sure that we do not use the same ids in both answer blocks. Additionally, the two blocks also need to have different names. Another important thing is that we have to include style='display:none' for each input, so that the formatting does not get lost. Suppose we want to show a sentence with two dropdown menus, which have three choices each, the code could look like this: const multi_dropdown_customized = magpieViews.view_generator( \"dropdown_choice\", // config information { trials: part_one_trial_info.dropdown_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.dropdown_choice }, // custom generator functions { answer_container_gen: function (config, CT) { return `<div class='magpie-view-answer-container magpie-response-multi-dropdown'> ${config.data[CT].sentence_chunk_1} <div class= 'response-table'> <input type='radio' name='answer1' id='o1' style='display:none value=${config.data[CT].choice_options_1[0]} /> <label for='o1' class='magpie-response-buttons'>${config.data[CT].choice_options_1[0]}</label> <input type='radio' name='answer1' id='o2' style='display:none' value=${config.data[CT].choice_options_1[1]} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].choice_options_1[1]}</label> <input type='radio' name='answer1' id='o3' style='display:none' value=${config.data[CT].choice_options_1[2]} /> <label for='o3' class='magpie-response-buttons'>${config.data[CT].choice_options_1[2]}</label> </div> ${config.data[CT].sentence_chunk_2} <div class= 'response-table'> <input type='radio' name='answer2' id='p1' style='display:none' value=${config.data[CT].choice_options_2[0]} /> <label for='p1' class='magpie-response-buttons'>${config.data[CT].choice_options_2[0]}</label> <input type='radio' name='answer2' id='p2' style='display:none' value=${config.data[CT].choice_options_2[1]} /> <label for='p2' class='magpie-response-buttons'>${config.data[CT].choice_options_2[1]}</label> <input type='radio' name='answer2' id='p3' style='display:none' value=${config.data[CT].choice_options_2[2]} /> <label for='p3' class='magpie-response-buttons'>${config.data[CT].choice_options_2[2]}</label> </div> ${config.data[CT].sentence_chunk_3} </div>`; } } ); It is possible to supply a completely new type of response variable via the function specified for answer_container_generator . However, you might need to make sure that the data is handled correctly. This is the job of the final third element you can use to customize a template view, namely handle_response_function . In other words, often the two design elements answer_container_generator and handle_response_function might need to be adjusted to each other. The handle_response_function used per default in the forced_choice view is this: function(config, CT, magpie, answer_container_generator, startingTime) { // create the answer container $(\".magpie-view\").append(answer_container_generator(config, CT)); // attaches an event listener to the radio button input // when an input is selected a response property with a value equal // to the answer is added to the trial object // as well as a readingTimes property with value $(\"input[name=answer]\").on(\"change\", function() { const RT = Date.now() - startingTime; let trial_data = { trial_name: config.name, trial_number: CT + 1, response: $(\"input[name=answer]:checked\").val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); } When this function is called (automatically by _magpie) it first creates the answer container. It also adds an event listener. Here, it reacts when a button is pressed, but this behavior needs to be coordinated with whatever you define in the answer_container_generator part. It then records the trial time and assembles the data to be recorded in the variable trial_data . By default, _magpie automatically adds all the data for the current trial to this object and then pushes this to its internal representation of the accumulated data so far which is in magpie.trial_data . The function magpie.findNextView is then called and takes you to the next trial or view. When you write your own custom handle_response_function you should supply the same arguments as the function above. You should also make sure to record the data and call magpie.findNextView eventually. Other than this, you could implement a more dynamic display of different pictures and response options, using the interplay of answer_container_generator and handle_response_function , for example. If you write longer custom functions for customization, it is good practice to put these into the file 02_custom_functions.js . An example is presented in the showroom . Predefined view elements Stimulus container generators The following predefined stimulus container generators are available. The template wrapping views and trial views defined in _magpie all use one of these, as listed here . // The view template dict contains a generator function for every view type we support // The generator gets the config dict and CT as input and will generate the magpie-view HTML code // (Some view templates are the same, e.g. forced_choice and sliderRating) const stimulus_container_generators = { basic_stimulus: function (config, CT) { return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-view-question magpie-view-qud'>${config.data[CT].QUD}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> </div>`; }, key_press: function(config, CT) { return `<div class=\"magpie-view\"> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-response-keypress-header'> <strong>${config.data[CT].key1}</strong> = ${config.data[CT][config.data[CT].key1]}, <strong>${config.data[CT].key2}</strong> = ${config.data[CT][config.data[CT].key2]}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> </div>`; }, fixed_text: function(config, CT) { return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <section class=\"magpie-text-container\"> <p class=\"magpie-view-text\">${config.text}</p> </section> </div>`; }, post_test: function(config, CT) { return `<div class='magpie-view magpie-post-test-view'> <h1 class='magpie-view-title'>${config.title}</h1> <section class=\"magpie-text-container\"> <p class=\"magpie-view-text\">${config.text}</p> </section> </div>`; }, empty: function(config, CT) { return ``; }, self_paced_reading: function(config, CT) { const helpText = config.data[CT].help_text !== undefined ? config.data[CT].help_text : \"Press the SPACE bar to reveal the words\"; return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-view-question magpie-view-qud'>${config.data[CT].QUD}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> <p class='magpie-help-text magpie-nodisplay'>${helpText}</p> <p class='magpie-spr-sentence'></p> </div>`; } }; Answer container generators The following predefined answer container generators are available. The template wrapping views and trial views defined in _magpie all use one of these, as listed here . // The answer container dict contains a generator function for every view type we support // The generator gets the config dict and CT as input and will generate the magpie-view-answer-container HTML code // (Some answer container elements should be the same, e.g. slider rating and SPR-slider rating) const answer_container_generators = { button_choice: function (config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for='o1' class='magpie-response-buttons'>${config.data[CT].option1}</label> <input type='radio' name='answer' id='o1' value=${config.data[CT].option1} /> <input type='radio' name='answer' id='o2' value=${config.data[CT].option2} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].option2}</label> </div>`; }, question: function(config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p>`; }, one_button: function (config, CT) { return `<button id=\"next\" class='magpie-view-button' class=\"magpie-nodisplay\">${ config.button }</button>` }, post_test: function(config, CT) { const quest = magpieUtils.view.fill_defaults_post_test(config); return `<form> <p class='magpie-view-text'> <label for=\"age\">${quest.age.title}:</label> <input type=\"number\" name=\"age\" min=\"18\" max=\"110\" id=\"age\" /> </p> <p class='magpie-view-text'> <label for=\"gender\">${quest.gender.title}:</label> <select id=\"gender\" name=\"gender\"> <option></option> <option value=\"${quest.gender.male}\">${quest.gender.male}</option> <option value=\"${quest.gender.female}\">${quest.gender.female}</option> <option value=\"${quest.gender.other}\">${quest.gender.other}</option> </select> </p> <p class='magpie-view-text'> <label for=\"education\">${quest.edu.title}:</label> <select id=\"education\" name=\"education\"> <option></option> <option value=\"${quest.edu.graduated_high_school}\">${quest.edu.graduated_high_school}</option> <option value=\"${quest.edu.graduated_college}\">${quest.edu.graduated_college}</option> <option value=\"${quest.edu.higher_degree}\">${quest.edu.higher_degree}</option> </select> </p> <p class='magpie-view-text'> <label for=\"languages\" name=\"languages\">${quest.langs.title}:<br /><span>${quest.langs.text}</</span></label> <input type=\"text\" id=\"languages\"/> </p> <p class=\"magpie-view-text\"> <label for=\"comments\">${quest.comments.title}</label> <textarea name=\"comments\" id=\"comments\" rows=\"6\" cols=\"40\"></textarea> </p> <button id=\"next\" class='magpie-view-button'>${config.button}</button> </form>` }, empty: function(config, CT) { return ``; }, slider_rating: function(config, CT) { const option1 = config.data[CT].optionLeft; const option2 = config.data[CT].optionRight; return `<p class='magpie-view-question'>${config.data[CT].question}</p> <div class='magpie-view-answer-container'> <span class='magpie-response-slider-option'>${option1}</span> <input type='range' id='response' class='magpie-response-slider' min='0' max='100' value='50'/> <span class='magpie-response-slider-option'>${option2}</span> </div> <button id=\"next\" class='magpie-view-button magpie-nodisplay'>Next</button>`; }, textbox_input: function(config, CT) { return `<p class='magpie-view-question'>${config.data[CT].question}</p> <div class='magpie-view-answer-container'> <textarea name='textbox-input' rows=10 cols=50 class='magpie-response-text' /> </div> <button id='next' class='magpie-view-button magpie-nodisplay'>next</button>`; }, dropdown_choice: function(config, CT) { const question_left_part = config.data[CT].question_left_part === undefined ? \"\" : config.data[CT].question_left_part; const question_right_part = config.data[CT].question_right_part === undefined ? \"\" : config.data[CT].question_right_part; const option1 = config.data[CT].option1; const option2 = config.data[CT].option2; return `<div class='magpie-view-answer-container magpie-response-dropdown'> ${question_left_part} <select id='response' name='answer'> <option disabled selected></option> <option value=${option1}>${option1}</option> <option value=${option2}>${option2}</option> </select> ${question_right_part} </p> <button id='next' class='magpie-view-button magpie-nodisplay'>Next</button> </div>`; }, rating_scale: function(config, CT) { return `<p class='magpie-view-question'>${config.data[CT].question}</p> <div class='magpie-view-answer-container'> <strong class='magpie-response-rating-option magpie-view-text'>${config.data[CT].optionLeft}</strong> <label for=\"1\" class='magpie-response-rating'>1</label> <input type=\"radio\" name=\"answer\" id=\"1\" value=\"1\" /> <label for=\"2\" class='magpie-response-rating'>2</label> <input type=\"radio\" name=\"answer\" id=\"2\" value=\"2\" /> <label for=\"3\" class='magpie-response-rating'>3</label> <input type=\"radio\" name=\"answer\" id=\"3\" value=\"3\" /> <label for=\"4\" class='magpie-response-rating'>4</label> <input type=\"radio\" name=\"answer\" id=\"4\" value=\"4\" /> <label for=\"5\" class='magpie-response-rating'>5</label> <input type=\"radio\" name=\"answer\" id=\"5\" value=\"5\" /> <label for=\"6\" class='magpie-response-rating'>6</label> <input type=\"radio\" name=\"answer\" id=\"6\" value=\"6\" /> <label for=\"7\" class='magpie-response-rating'>7</label> <input type=\"radio\" name=\"answer\" id=\"7\" value=\"7\" /> <strong class='magpie-response-rating-option magpie-view-text'>${config.data[CT].optionRight}</strong> </div>`; }, sentence_choice: function(config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for='s1' class='magpie-response-sentence'>${config.data[CT].option1}</label> <input type='radio' name='answer' id='s1' value=\"${config.data[CT].option1}\" /> <label for='s2' class='magpie-response-sentence'>${config.data[CT].option2}</label> <input type='radio' name='answer' id='s2' value=\"${config.data[CT].option2}\" /> </div>`; }, image_selection: function(config, CT) { $(\".magpie-view-stimulus-container\").addClass(\"magpie-nodisplay\"); return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for=\"img1\" class='magpie-view-picture magpie-response-picture'><img src=${config.data[CT].picture1}></label> <input type=\"radio\" name=\"answer\" id=\"img1\" value=\"${config.data[CT].option1}\" /> <input type=\"radio\" name=\"answer\" id=\"img2\" value=\"${config.data[CT].option2}\" /> <label for=\"img2\" class='magpie-view-picture magpie-response-picture'><img src=${config.data[CT].picture2}></label> </div>`; } }; Handle response functions The following predefined handle response functions are available. The template wrapping views and trial views defined in _magpie all use one of these, as listed here . // The enable response dict contains a generator function for every view type we support // The generator gets the config dict, CT, the answer_container_generator and the startingTime as input const handle_response_functions = { button_choice: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); // attaches an event listener to the yes / no radio inputs // when an input is selected a response property with a value equal // to the answer is added to the trial object // as well as a readingTimes property with value $(\"input[name=answer]\").on(\"change\", function() { const RT = Date.now() - startingTime; let trial_data = { trial_name: config.name, trial_number: CT + 1, response: $(\"input[name=answer]:checked\").val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, key_press: function (config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); const handleKeyPress = function(e) { const keyPressed = String.fromCharCode( e.which ).toLowerCase(); if (keyPressed === config.data[CT].key1 || keyPressed === config.data[CT].key2) { let correctness; const RT = Date.now() - startingTime; // measure RT before anything else if ( config.data[CT].expected === config.data[CT][keyPressed.toLowerCase()] ) { correctness = \"correct\"; } else { correctness = \"incorrect\"; } let trial_data = { trial_name: config.name, trial_number: CT + 1, key_pressed: keyPressed, correctness: correctness, RT: RT }; trial_data[config.data[CT].key1] = config.data[CT][config.data[CT].key1]; trial_data[config.data[CT].key2] = config.data[CT][config.data[CT].key2]; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); $(\"body\").off(\"keydown\", handleKeyPress); magpie.findNextView(); } }; $(\"body\").on(\"keydown\", handleKeyPress); }, intro: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); let prolificId; const prolificForm = `<p id=\"prolific-id-form\"> <label for=\"prolific-id\">Please, enter your Prolific ID</label> <input type=\"text\" id=\"prolific-id\" /> </p>`; const next = $(\"#next\"); function showNextBtn() { if (prolificId.val().trim() !== \"\") { next.removeClass(\"magpie-nodisplay\"); } else { next.addClass(\"magpie-nodisplay\"); } } if (magpie.deploy.deployMethod === \"Prolific\") { $(\".magpie-text-container\").append(prolificForm); next.addClass(\"magpie-nodisplay\"); prolificId = $(\"#prolific-id\"); prolificId.on(\"keyup\", function() { showNextBtn(); }); prolificId.on(\"focus\", function() { showNextBtn(); }); } // moves to the next view next.on(\"click\", function() { if (magpie.deploy.deployMethod === \"Prolific\") { magpie.global_data.prolific_id = prolificId.val().trim(); } magpie.findNextView(); }); }, one_click: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); $(\"#next\").on(\"click\", function() { magpie.findNextView(); }); }, post_test: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); $(\"#next\").on(\"click\", function(e) { // prevents the form from submitting e.preventDefault(); // records the post test info magpie.global_data.age = $(\"#age\").val(); magpie.global_data.gender = $(\"#gender\").val(); magpie.global_data.education = $(\"#education\").val(); magpie.global_data.languages = $(\"#languages\").val(); magpie.global_data.comments = $(\"#comments\") .val() .trim(); magpie.global_data.endTime = Date.now(); magpie.global_data.timeSpent = (magpie.global_data.endTime - magpie.global_data.startTime) / 60000; // moves to the next view magpie.findNextView(); }); }, thanks: function(config, CT, magpie, answer_container_generator, startingTime) { const prolificConfirmText = magpieUtils.view.setter.prolificConfirmText(config.prolificConfirmText, \"Please press the button below to confirm that you completed the experiment with Prolific\"); if ( magpie.deploy.is_MTurk || magpie.deploy.deployMethod === \"directLink\" || magpie.deploy.deployMethod === \"localServer\" ) { // updates the fields in the hidden form with info for the MTurk's server $(\"#main\").html( `<div class='magpie-view magpie-thanks-view'> <h2 id='warning-message' class='magpie-warning'>Submitting the data <p class='magpie-view-text'>please do not close the tab</p> <div class='magpie-loader'></div> </h2> <h1 id='thanks-message' class='magpie-thanks magpie-nodisplay'>${ config.title }</h1> </div>` ); } else if (magpie.deploy.deployMethod === \"Prolific\") { $(\"#main\").html( `<div class='magpie-view magpie-thanks-view'> <h2 id='warning-message' class='magpie-warning'>Submitting the data <p class='magpie-view-text'>please do not close the tab</p> <div class='magpie-loader'></div> </h2> <h1 id='thanks-message' class='magpie-thanks magpie-nodisplay'>${ config.title }</h1> <p id='extra-message' class='magpie-view-text magpie-nodisplay'> ${prolificConfirmText} <a href=\"${ magpie.deploy.prolificURL }\" class=\"magpie-view-button prolific-url\">Confirm</a> </p> </div>` ); } else if (magpie.deploy.deployMethod === \"debug\") { $(\"main\").html( `<div id='magpie-debug-table-container' class='magpie-view magpie-thanks-view'> <h1 class='magpie-view-title'>Debug Mode</h1> </div>` ); } else { console.error(\"No such magpie.deploy.deployMethod\"); } magpie.submission.submit(magpie); }, slider_rating: function(config, CT, magpie, answer_container_generator, startingTime){ let response; $(\".magpie-view\").append(answer_container_generator(config, CT)); response = $(\"#response\"); // checks if the slider has been changed response.on(\"change\", function() { $(\"#next\").removeClass(\"magpie-nodisplay\"); }); response.on(\"click\", function() { $(\"#next\").removeClass(\"magpie-nodisplay\"); }); $(\"#next\").on(\"click\", function() { const RT = Date.now() - startingTime; // measure RT before anything else let trial_data = { trial_name: config.name, trial_number: CT + 1, response: response.val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, textbox_input: function(config, CT, magpie, answer_container_generator, startingTime) { let next; let textInput; const minChars = config.data[CT].min_chars === undefined ? 10 : config.data[CT].min_chars; $(\".magpie-view\").append(answer_container_generator(config, CT)); next = $(\"#next\"); textInput = $(\"textarea\"); // attaches an event listener to the textbox input textInput.on(\"keyup\", function() { // if the text is longer than (in this case) 10 characters without the spaces // the 'next' button appears if (textInput.val().trim().length > minChars) { next.removeClass(\"magpie-nodisplay\"); } else { next.addClass(\"magpie-nodisplay\"); } }); // the trial data gets added to the trial object next.on(\"click\", function() { const RT = Date.now() - startingTime; // measure RT before anything else let trial_data = { trial_name: config.name, trial_number: CT + 1, response: textInput.val().trim(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, dropdown_choice: function(config, CT, magpie, answer_container_generator, startingTime){ let response; const question_left_part = config.data[CT].question_left_part === undefined ? \"\" : config.data[CT].question_left_part; const question_right_part = config.data[CT].question_right_part === undefined ? \"\" : config.data[CT].question_right_part; $(\".magpie-view\").append(answer_container_generator(config, CT)); response = $(\"#response\"); response.on(\"change\", function() { $(\"#next\").removeClass(\"magpie-nodisplay\"); }); $(\"#next\").on(\"click\", function() { const RT = Date.now() - startingTime; // measure RT before anything else let trial_data = { trial_name: config.name, trial_number: CT + 1, question: question_left_part.concat(\"...answer here...\").concat(question_right_part), response: response.val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, self_paced_reading: function(config, CT, magpie, answer_container_generator, startingTime){ const sentenceList = config.data[CT].sentence.trim().split(\" | \"); let spaceCounter = 0; let wordList; let readingTimes = []; // wordPos \"next\" or \"same\", if \"next\" words appear next to each other, if \"same\" all words appear at the same place // default: \"next\" let wordPos = config.data[CT].wordPos === undefined ? \"next\" : config.data[CT].wordPos; let showNeighbor = wordPos === \"next\"; // underline \"words\", \"sentence\" or \"none\", if \"words\" every word gets underlined, if \"sentence\" the sentence gets // underlined, if \"none\" there is no underline // default: \"words\" let underline = config.data[CT].underline === undefined ? \"words\" : config.data[CT].underline; let not_underline = underline === \"none\"; let one_line = underline === \"sentence\"; // shows the sentence word by word on SPACE press const handle_key_press = function(e) { if (e.which === 32 && spaceCounter < sentenceList.length) { if (showNeighbor) { wordList[spaceCounter].classList.remove(\"spr-word-hidden\"); } else { $(\".magpie-spr-sentence\").html(`<span class='spr-word'>${sentenceList[spaceCounter]}</span>`); if (not_underline){ $('.magpie-spr-sentence .spr-word').addClass('no-line'); } } if (spaceCounter === 0) { $(\".magpie-help-text\").addClass(\"magpie-invisible\"); } if (spaceCounter > 0 && showNeighbor) { wordList[spaceCounter - 1].classList.add(\"spr-word-hidden\"); } readingTimes.push(Date.now()); spaceCounter++; } else if (e.which === 32 && spaceCounter === sentenceList.length) { if (showNeighbor) { wordList[spaceCounter - 1].classList.add(\"spr-word-hidden\"); } else { $(\".magpie-spr-sentence\").html(\"\"); } $(\".magpie-view\").append(answer_container_generator(config, CT)); $(\"input[name=answer]\").on(\"change\", function() { const RT = Date.now() - startingTime; let reactionTimes = readingTimes .reduce((result, current, idx) => { return result.concat( readingTimes[idx + 1] - readingTimes[idx] ); }, []) .filter((item) => isNaN(item) === false); let trial_data = { trial_name: config.name, trial_number: CT + 1, response: $(\"input[name=answer]:checked\").val(), reaction_times: reactionTimes, time_spent: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); readingTimes.push(Date.now()); spaceCounter++; } }; // shows the help text $(\".magpie-help-text\").removeClass(\"magpie-nodisplay\"); if (showNeighbor) { // creates the sentence sentenceList.map((word) => { $(\".magpie-spr-sentence\").append( `<span class='spr-word spr-word-hidden'>${word}</span>` ); }); // creates an array of spr word elements wordList = $(\".spr-word\").toArray(); } if (not_underline){ $('.magpie-spr-sentence .spr-word').addClass('no-line'); } if (one_line){ $('.magpie-spr-sentence .spr-word').addClass('one-line'); } // attaches an eventListener to the body for space $(\"body\").on(\"keydown\", handle_key_press); } }; Defining a custom view from scratch You can also define a custom view from scratch. To do this, create a view template, ideally in file 03_custom_views_templates.js . A view template gets a config object information as input (with relevant information, e.g., URLs for pictures, text to show on each trial etc.). The view template function then returns a view. Here's a basic scaffolding of a view template: const custom_view_template = function(config) { const view = { name: config.name, CT: 0, trials: config.trials, // The render functions gets the magpie object as well as the current trial in view counter as input render: function (CT, magpie) { // Here, you can do whatever you want, eventually you should call magpie.findNextView() // to proceed to the next view and if it is an trial type view, // you should save the trial information with magpie.trial_data.push(trial_data) } }; // We have to return the view, so that it can be used in 05_views.js return view; }; A view is an object, that obligatorily has the properties: name : the view's name CT : the view's current trial (the counter of how many times this view occurred in the experiment, initialized to 0) trials : the maximum number of times this view is repeated render : a function that is called to create each trial of the view The most important part is the render function. It gets CT and the magpie-object itself as input. has to call magpie.findNextView() eventually to proceed to the next view (or the next trial in this view). If data is to be saved from any given trial, you would need to collect the data as an object, e.g., named trial_data and store it for later output by calling magpie.trial_data.push(trial_data) . Here's a full example from the showroom : // In this view the user can click on one of two buttons const custom_press_a_button = function(config) { const view = { name: config.name, CT: 0, trials: config.trials, // The render functions gets the magpie object as well as the current trial in view counter as input render: function (CT, magpie) { // Here, you can do whatever you want, eventually you should call magpie.findNextView() // to proceed to the next view and if it is an trial type view, // you should save the trial information with magpie.trial_data.push(trial_data) // Normally, you want to display some kind of html, to do this you append your html to the main element // You could use one of our predefined html-templates, with (magpie.)stimulus_container_generators[\"<view_name>\"](config, CT) $(\"main\").html(`<div class='magpie-view'> <h1 class='magpie-view-title'>Click on one of the buttons!</h1> <button id=\"first\" class='magpie-view-button'>First Button</button> <button id=\"second\" class='magpie-view-button'>Second Button</button> </div>`); // This function will handle the response const handle_click = function(e) { // We will just save the response and continue to the next view let trial_data = { trial_name: config.name, trial_number: CT + 1, response: e.target.id }; // Often it makes sense to also save the config information // trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); // Here, we save the trial_data magpie.trial_data.push(trial_data); // Now, we will continue with the next view magpie.findNextView(); }; // We will add the handle_click functions to both buttons $('#first').on(\"click\", handle_click); $('#second').on(\"click\", handle_click); // That's everything for this view } }; // We have to return the view, so that it can be used in 05_views.js return view; };","title":"Custom views"},{"location":"01_designing_experiments/03_custom_views/#custom-views","text":"When the template views are not enough for your purposes, you can define your own custom views. There are two ways of doing this. The first possibility is to customize the template views . You would then keep the basic structure and design of a template view and change selected parts of it. Since all predefined template views consist of modular predefined view elements , you can often modularly assemble and tweak your desired view functionality based on slight changes of the template views. The other, more radical method is to define a completely new view from scratch .","title":"Custom views"},{"location":"01_designing_experiments/03_custom_views/#customizing-template-views","text":"Each template view consists of three elements, which jointly define its appearance and functionality: stimulus container : defines the top part of the screen, containing stuff like title, the QUD, the stimulus to be shown etc. answer container : defines the lower part of the screen, containing the answer options, 'next' buttons, etc. handle response function : function that is called to handle the response Each one of these elements is independently customizable. Indeed, when a template view is created by _magpie \"behind the scenes\", it simply uses defaults for these three elements which are appropriate for the template view to be created. For example, we would normally create a template forced_choice view like so: const forced_choice_instance = magpieViews.view_generator( 'forced_choice', // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice } ); Equivalently, we could write this: const forced_choice_instance = magpieViews.view_generator( 'forced_choice', // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice }, // custom generator functions { stimulus_container_generator: stimulus_container_generators.basic_stimulus, answer_container_generator: answer_container_generators.button_choice, handle_response_function: handle_response_functions.button_choice } ); Here, we supply a third object with custom generator functions, one for each of the three elements. Since the second code box just uses the defaults which are implicit in the first, the two calls are equivalent. The description of template views lists which view elements each template view uses. All predefined view elements are listed and shown below . The stimulus generator function used by the template forced_choice view is this: function (config, CT) { return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-view-question magpie-view-qud'>${config.data[CT].QUD}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> </div>`; Generally, the function supplied to stimulus_container_generator must take the config object and a CT argument. The latter is the current trial, and it is supplied by _magpie internally. The function should then return HTML code as a string, which governs the appearance of the upper part of the view screen. You can use information from config and CT , so that when we write ${config.data[CT].QUD} in the HTML string to be returned this is replaced by the QUD information stored in config for the current trial. Notice that the picture element is inserted automatically by _magpie in the magpie-view-stimulus container. We can specify whatever we'd like to appear in the stimulus container. For example, let's insert the same picture twice. This can be done by instantiating a customized template view like so: const forced_choice_customized = magpieViews.view_generator( \"forced_choice\", // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice }, // custom generator functions { stimulus_container_generator: function (config, CT) { return `<div class='magpie-view'> <div class='magpie-view-stimulus-container'> <img src=\"${config.data[CT].picture}\" height=\"42\" width=\"42\"> <img src=\"${config.data[CT].picture}\" height=\"42\" width=\"42\"> </div> </div>`;} } ); We can also change the design and behavior of the part of the view that deals with the response. Per default, the forced_choice view uses a predefined function button_choice to have the user select one of two buttons. Suppose we wanted to have a third button. We could then use code like the following (which only works, if we define option3 in 04_trials.js as well, of course): const forced_choice_customized = magpieViews.view_generator( \"forced_choice\", // config information { trials: part_one_trial_info.forced_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.forced_choice }, // custom generator functions { answer_container_generator: function (config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for='o1' class='magpie-response-buttons'>${config.data[CT].option1}</label> <input type='radio' name='answer' id='o1' value=${config.data[CT].option1} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].option2}</label> <input type='radio' name='answer' id='o2' value=${config.data[CT].option2} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].option3}</label> <input type='radio' name='answer' id='o3' value=${config.data[CT].option3} /> </div>`; } } ); If we want to have more than one answer within the same view, we can of course also do so. There are only a few things which we have to keep in mind. The id of each input has to be unique, so we have to make sure that we do not use the same ids in both answer blocks. Additionally, the two blocks also need to have different names. Another important thing is that we have to include style='display:none' for each input, so that the formatting does not get lost. Suppose we want to show a sentence with two dropdown menus, which have three choices each, the code could look like this: const multi_dropdown_customized = magpieViews.view_generator( \"dropdown_choice\", // config information { trials: part_one_trial_info.dropdown_choice.length, name: 'rebuilt_FC', data: part_one_trial_info.dropdown_choice }, // custom generator functions { answer_container_gen: function (config, CT) { return `<div class='magpie-view-answer-container magpie-response-multi-dropdown'> ${config.data[CT].sentence_chunk_1} <div class= 'response-table'> <input type='radio' name='answer1' id='o1' style='display:none value=${config.data[CT].choice_options_1[0]} /> <label for='o1' class='magpie-response-buttons'>${config.data[CT].choice_options_1[0]}</label> <input type='radio' name='answer1' id='o2' style='display:none' value=${config.data[CT].choice_options_1[1]} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].choice_options_1[1]}</label> <input type='radio' name='answer1' id='o3' style='display:none' value=${config.data[CT].choice_options_1[2]} /> <label for='o3' class='magpie-response-buttons'>${config.data[CT].choice_options_1[2]}</label> </div> ${config.data[CT].sentence_chunk_2} <div class= 'response-table'> <input type='radio' name='answer2' id='p1' style='display:none' value=${config.data[CT].choice_options_2[0]} /> <label for='p1' class='magpie-response-buttons'>${config.data[CT].choice_options_2[0]}</label> <input type='radio' name='answer2' id='p2' style='display:none' value=${config.data[CT].choice_options_2[1]} /> <label for='p2' class='magpie-response-buttons'>${config.data[CT].choice_options_2[1]}</label> <input type='radio' name='answer2' id='p3' style='display:none' value=${config.data[CT].choice_options_2[2]} /> <label for='p3' class='magpie-response-buttons'>${config.data[CT].choice_options_2[2]}</label> </div> ${config.data[CT].sentence_chunk_3} </div>`; } } ); It is possible to supply a completely new type of response variable via the function specified for answer_container_generator . However, you might need to make sure that the data is handled correctly. This is the job of the final third element you can use to customize a template view, namely handle_response_function . In other words, often the two design elements answer_container_generator and handle_response_function might need to be adjusted to each other. The handle_response_function used per default in the forced_choice view is this: function(config, CT, magpie, answer_container_generator, startingTime) { // create the answer container $(\".magpie-view\").append(answer_container_generator(config, CT)); // attaches an event listener to the radio button input // when an input is selected a response property with a value equal // to the answer is added to the trial object // as well as a readingTimes property with value $(\"input[name=answer]\").on(\"change\", function() { const RT = Date.now() - startingTime; let trial_data = { trial_name: config.name, trial_number: CT + 1, response: $(\"input[name=answer]:checked\").val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); } When this function is called (automatically by _magpie) it first creates the answer container. It also adds an event listener. Here, it reacts when a button is pressed, but this behavior needs to be coordinated with whatever you define in the answer_container_generator part. It then records the trial time and assembles the data to be recorded in the variable trial_data . By default, _magpie automatically adds all the data for the current trial to this object and then pushes this to its internal representation of the accumulated data so far which is in magpie.trial_data . The function magpie.findNextView is then called and takes you to the next trial or view. When you write your own custom handle_response_function you should supply the same arguments as the function above. You should also make sure to record the data and call magpie.findNextView eventually. Other than this, you could implement a more dynamic display of different pictures and response options, using the interplay of answer_container_generator and handle_response_function , for example. If you write longer custom functions for customization, it is good practice to put these into the file 02_custom_functions.js . An example is presented in the showroom .","title":"Customizing template views"},{"location":"01_designing_experiments/03_custom_views/#predefined-view-elements","text":"","title":"Predefined view elements"},{"location":"01_designing_experiments/03_custom_views/#stimulus-container-generators","text":"The following predefined stimulus container generators are available. The template wrapping views and trial views defined in _magpie all use one of these, as listed here . // The view template dict contains a generator function for every view type we support // The generator gets the config dict and CT as input and will generate the magpie-view HTML code // (Some view templates are the same, e.g. forced_choice and sliderRating) const stimulus_container_generators = { basic_stimulus: function (config, CT) { return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-view-question magpie-view-qud'>${config.data[CT].QUD}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> </div>`; }, key_press: function(config, CT) { return `<div class=\"magpie-view\"> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-response-keypress-header'> <strong>${config.data[CT].key1}</strong> = ${config.data[CT][config.data[CT].key1]}, <strong>${config.data[CT].key2}</strong> = ${config.data[CT][config.data[CT].key2]}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> </div>`; }, fixed_text: function(config, CT) { return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <section class=\"magpie-text-container\"> <p class=\"magpie-view-text\">${config.text}</p> </section> </div>`; }, post_test: function(config, CT) { return `<div class='magpie-view magpie-post-test-view'> <h1 class='magpie-view-title'>${config.title}</h1> <section class=\"magpie-text-container\"> <p class=\"magpie-view-text\">${config.text}</p> </section> </div>`; }, empty: function(config, CT) { return ``; }, self_paced_reading: function(config, CT) { const helpText = config.data[CT].help_text !== undefined ? config.data[CT].help_text : \"Press the SPACE bar to reveal the words\"; return `<div class='magpie-view'> <h1 class='magpie-view-title'>${config.title}</h1> <p class='magpie-view-question magpie-view-qud'>${config.data[CT].QUD}</p> <div class='magpie-view-stimulus-container'> <div class='magpie-view-stimulus magpie-nodisplay'></div> </div> <p class='magpie-help-text magpie-nodisplay'>${helpText}</p> <p class='magpie-spr-sentence'></p> </div>`; } };","title":"Stimulus container generators"},{"location":"01_designing_experiments/03_custom_views/#answer-container-generators","text":"The following predefined answer container generators are available. The template wrapping views and trial views defined in _magpie all use one of these, as listed here . // The answer container dict contains a generator function for every view type we support // The generator gets the config dict and CT as input and will generate the magpie-view-answer-container HTML code // (Some answer container elements should be the same, e.g. slider rating and SPR-slider rating) const answer_container_generators = { button_choice: function (config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for='o1' class='magpie-response-buttons'>${config.data[CT].option1}</label> <input type='radio' name='answer' id='o1' value=${config.data[CT].option1} /> <input type='radio' name='answer' id='o2' value=${config.data[CT].option2} /> <label for='o2' class='magpie-response-buttons'>${config.data[CT].option2}</label> </div>`; }, question: function(config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p>`; }, one_button: function (config, CT) { return `<button id=\"next\" class='magpie-view-button' class=\"magpie-nodisplay\">${ config.button }</button>` }, post_test: function(config, CT) { const quest = magpieUtils.view.fill_defaults_post_test(config); return `<form> <p class='magpie-view-text'> <label for=\"age\">${quest.age.title}:</label> <input type=\"number\" name=\"age\" min=\"18\" max=\"110\" id=\"age\" /> </p> <p class='magpie-view-text'> <label for=\"gender\">${quest.gender.title}:</label> <select id=\"gender\" name=\"gender\"> <option></option> <option value=\"${quest.gender.male}\">${quest.gender.male}</option> <option value=\"${quest.gender.female}\">${quest.gender.female}</option> <option value=\"${quest.gender.other}\">${quest.gender.other}</option> </select> </p> <p class='magpie-view-text'> <label for=\"education\">${quest.edu.title}:</label> <select id=\"education\" name=\"education\"> <option></option> <option value=\"${quest.edu.graduated_high_school}\">${quest.edu.graduated_high_school}</option> <option value=\"${quest.edu.graduated_college}\">${quest.edu.graduated_college}</option> <option value=\"${quest.edu.higher_degree}\">${quest.edu.higher_degree}</option> </select> </p> <p class='magpie-view-text'> <label for=\"languages\" name=\"languages\">${quest.langs.title}:<br /><span>${quest.langs.text}</</span></label> <input type=\"text\" id=\"languages\"/> </p> <p class=\"magpie-view-text\"> <label for=\"comments\">${quest.comments.title}</label> <textarea name=\"comments\" id=\"comments\" rows=\"6\" cols=\"40\"></textarea> </p> <button id=\"next\" class='magpie-view-button'>${config.button}</button> </form>` }, empty: function(config, CT) { return ``; }, slider_rating: function(config, CT) { const option1 = config.data[CT].optionLeft; const option2 = config.data[CT].optionRight; return `<p class='magpie-view-question'>${config.data[CT].question}</p> <div class='magpie-view-answer-container'> <span class='magpie-response-slider-option'>${option1}</span> <input type='range' id='response' class='magpie-response-slider' min='0' max='100' value='50'/> <span class='magpie-response-slider-option'>${option2}</span> </div> <button id=\"next\" class='magpie-view-button magpie-nodisplay'>Next</button>`; }, textbox_input: function(config, CT) { return `<p class='magpie-view-question'>${config.data[CT].question}</p> <div class='magpie-view-answer-container'> <textarea name='textbox-input' rows=10 cols=50 class='magpie-response-text' /> </div> <button id='next' class='magpie-view-button magpie-nodisplay'>next</button>`; }, dropdown_choice: function(config, CT) { const question_left_part = config.data[CT].question_left_part === undefined ? \"\" : config.data[CT].question_left_part; const question_right_part = config.data[CT].question_right_part === undefined ? \"\" : config.data[CT].question_right_part; const option1 = config.data[CT].option1; const option2 = config.data[CT].option2; return `<div class='magpie-view-answer-container magpie-response-dropdown'> ${question_left_part} <select id='response' name='answer'> <option disabled selected></option> <option value=${option1}>${option1}</option> <option value=${option2}>${option2}</option> </select> ${question_right_part} </p> <button id='next' class='magpie-view-button magpie-nodisplay'>Next</button> </div>`; }, rating_scale: function(config, CT) { return `<p class='magpie-view-question'>${config.data[CT].question}</p> <div class='magpie-view-answer-container'> <strong class='magpie-response-rating-option magpie-view-text'>${config.data[CT].optionLeft}</strong> <label for=\"1\" class='magpie-response-rating'>1</label> <input type=\"radio\" name=\"answer\" id=\"1\" value=\"1\" /> <label for=\"2\" class='magpie-response-rating'>2</label> <input type=\"radio\" name=\"answer\" id=\"2\" value=\"2\" /> <label for=\"3\" class='magpie-response-rating'>3</label> <input type=\"radio\" name=\"answer\" id=\"3\" value=\"3\" /> <label for=\"4\" class='magpie-response-rating'>4</label> <input type=\"radio\" name=\"answer\" id=\"4\" value=\"4\" /> <label for=\"5\" class='magpie-response-rating'>5</label> <input type=\"radio\" name=\"answer\" id=\"5\" value=\"5\" /> <label for=\"6\" class='magpie-response-rating'>6</label> <input type=\"radio\" name=\"answer\" id=\"6\" value=\"6\" /> <label for=\"7\" class='magpie-response-rating'>7</label> <input type=\"radio\" name=\"answer\" id=\"7\" value=\"7\" /> <strong class='magpie-response-rating-option magpie-view-text'>${config.data[CT].optionRight}</strong> </div>`; }, sentence_choice: function(config, CT) { return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for='s1' class='magpie-response-sentence'>${config.data[CT].option1}</label> <input type='radio' name='answer' id='s1' value=\"${config.data[CT].option1}\" /> <label for='s2' class='magpie-response-sentence'>${config.data[CT].option2}</label> <input type='radio' name='answer' id='s2' value=\"${config.data[CT].option2}\" /> </div>`; }, image_selection: function(config, CT) { $(\".magpie-view-stimulus-container\").addClass(\"magpie-nodisplay\"); return `<div class='magpie-view-answer-container'> <p class='magpie-view-question'>${config.data[CT].question}</p> <label for=\"img1\" class='magpie-view-picture magpie-response-picture'><img src=${config.data[CT].picture1}></label> <input type=\"radio\" name=\"answer\" id=\"img1\" value=\"${config.data[CT].option1}\" /> <input type=\"radio\" name=\"answer\" id=\"img2\" value=\"${config.data[CT].option2}\" /> <label for=\"img2\" class='magpie-view-picture magpie-response-picture'><img src=${config.data[CT].picture2}></label> </div>`; } };","title":"Answer container generators"},{"location":"01_designing_experiments/03_custom_views/#handle-response-functions","text":"The following predefined handle response functions are available. The template wrapping views and trial views defined in _magpie all use one of these, as listed here . // The enable response dict contains a generator function for every view type we support // The generator gets the config dict, CT, the answer_container_generator and the startingTime as input const handle_response_functions = { button_choice: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); // attaches an event listener to the yes / no radio inputs // when an input is selected a response property with a value equal // to the answer is added to the trial object // as well as a readingTimes property with value $(\"input[name=answer]\").on(\"change\", function() { const RT = Date.now() - startingTime; let trial_data = { trial_name: config.name, trial_number: CT + 1, response: $(\"input[name=answer]:checked\").val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, key_press: function (config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); const handleKeyPress = function(e) { const keyPressed = String.fromCharCode( e.which ).toLowerCase(); if (keyPressed === config.data[CT].key1 || keyPressed === config.data[CT].key2) { let correctness; const RT = Date.now() - startingTime; // measure RT before anything else if ( config.data[CT].expected === config.data[CT][keyPressed.toLowerCase()] ) { correctness = \"correct\"; } else { correctness = \"incorrect\"; } let trial_data = { trial_name: config.name, trial_number: CT + 1, key_pressed: keyPressed, correctness: correctness, RT: RT }; trial_data[config.data[CT].key1] = config.data[CT][config.data[CT].key1]; trial_data[config.data[CT].key2] = config.data[CT][config.data[CT].key2]; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); $(\"body\").off(\"keydown\", handleKeyPress); magpie.findNextView(); } }; $(\"body\").on(\"keydown\", handleKeyPress); }, intro: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); let prolificId; const prolificForm = `<p id=\"prolific-id-form\"> <label for=\"prolific-id\">Please, enter your Prolific ID</label> <input type=\"text\" id=\"prolific-id\" /> </p>`; const next = $(\"#next\"); function showNextBtn() { if (prolificId.val().trim() !== \"\") { next.removeClass(\"magpie-nodisplay\"); } else { next.addClass(\"magpie-nodisplay\"); } } if (magpie.deploy.deployMethod === \"Prolific\") { $(\".magpie-text-container\").append(prolificForm); next.addClass(\"magpie-nodisplay\"); prolificId = $(\"#prolific-id\"); prolificId.on(\"keyup\", function() { showNextBtn(); }); prolificId.on(\"focus\", function() { showNextBtn(); }); } // moves to the next view next.on(\"click\", function() { if (magpie.deploy.deployMethod === \"Prolific\") { magpie.global_data.prolific_id = prolificId.val().trim(); } magpie.findNextView(); }); }, one_click: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); $(\"#next\").on(\"click\", function() { magpie.findNextView(); }); }, post_test: function(config, CT, magpie, answer_container_generator, startingTime) { $(\".magpie-view\").append(answer_container_generator(config, CT)); $(\"#next\").on(\"click\", function(e) { // prevents the form from submitting e.preventDefault(); // records the post test info magpie.global_data.age = $(\"#age\").val(); magpie.global_data.gender = $(\"#gender\").val(); magpie.global_data.education = $(\"#education\").val(); magpie.global_data.languages = $(\"#languages\").val(); magpie.global_data.comments = $(\"#comments\") .val() .trim(); magpie.global_data.endTime = Date.now(); magpie.global_data.timeSpent = (magpie.global_data.endTime - magpie.global_data.startTime) / 60000; // moves to the next view magpie.findNextView(); }); }, thanks: function(config, CT, magpie, answer_container_generator, startingTime) { const prolificConfirmText = magpieUtils.view.setter.prolificConfirmText(config.prolificConfirmText, \"Please press the button below to confirm that you completed the experiment with Prolific\"); if ( magpie.deploy.is_MTurk || magpie.deploy.deployMethod === \"directLink\" || magpie.deploy.deployMethod === \"localServer\" ) { // updates the fields in the hidden form with info for the MTurk's server $(\"#main\").html( `<div class='magpie-view magpie-thanks-view'> <h2 id='warning-message' class='magpie-warning'>Submitting the data <p class='magpie-view-text'>please do not close the tab</p> <div class='magpie-loader'></div> </h2> <h1 id='thanks-message' class='magpie-thanks magpie-nodisplay'>${ config.title }</h1> </div>` ); } else if (magpie.deploy.deployMethod === \"Prolific\") { $(\"#main\").html( `<div class='magpie-view magpie-thanks-view'> <h2 id='warning-message' class='magpie-warning'>Submitting the data <p class='magpie-view-text'>please do not close the tab</p> <div class='magpie-loader'></div> </h2> <h1 id='thanks-message' class='magpie-thanks magpie-nodisplay'>${ config.title }</h1> <p id='extra-message' class='magpie-view-text magpie-nodisplay'> ${prolificConfirmText} <a href=\"${ magpie.deploy.prolificURL }\" class=\"magpie-view-button prolific-url\">Confirm</a> </p> </div>` ); } else if (magpie.deploy.deployMethod === \"debug\") { $(\"main\").html( `<div id='magpie-debug-table-container' class='magpie-view magpie-thanks-view'> <h1 class='magpie-view-title'>Debug Mode</h1> </div>` ); } else { console.error(\"No such magpie.deploy.deployMethod\"); } magpie.submission.submit(magpie); }, slider_rating: function(config, CT, magpie, answer_container_generator, startingTime){ let response; $(\".magpie-view\").append(answer_container_generator(config, CT)); response = $(\"#response\"); // checks if the slider has been changed response.on(\"change\", function() { $(\"#next\").removeClass(\"magpie-nodisplay\"); }); response.on(\"click\", function() { $(\"#next\").removeClass(\"magpie-nodisplay\"); }); $(\"#next\").on(\"click\", function() { const RT = Date.now() - startingTime; // measure RT before anything else let trial_data = { trial_name: config.name, trial_number: CT + 1, response: response.val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, textbox_input: function(config, CT, magpie, answer_container_generator, startingTime) { let next; let textInput; const minChars = config.data[CT].min_chars === undefined ? 10 : config.data[CT].min_chars; $(\".magpie-view\").append(answer_container_generator(config, CT)); next = $(\"#next\"); textInput = $(\"textarea\"); // attaches an event listener to the textbox input textInput.on(\"keyup\", function() { // if the text is longer than (in this case) 10 characters without the spaces // the 'next' button appears if (textInput.val().trim().length > minChars) { next.removeClass(\"magpie-nodisplay\"); } else { next.addClass(\"magpie-nodisplay\"); } }); // the trial data gets added to the trial object next.on(\"click\", function() { const RT = Date.now() - startingTime; // measure RT before anything else let trial_data = { trial_name: config.name, trial_number: CT + 1, response: textInput.val().trim(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, dropdown_choice: function(config, CT, magpie, answer_container_generator, startingTime){ let response; const question_left_part = config.data[CT].question_left_part === undefined ? \"\" : config.data[CT].question_left_part; const question_right_part = config.data[CT].question_right_part === undefined ? \"\" : config.data[CT].question_right_part; $(\".magpie-view\").append(answer_container_generator(config, CT)); response = $(\"#response\"); response.on(\"change\", function() { $(\"#next\").removeClass(\"magpie-nodisplay\"); }); $(\"#next\").on(\"click\", function() { const RT = Date.now() - startingTime; // measure RT before anything else let trial_data = { trial_name: config.name, trial_number: CT + 1, question: question_left_part.concat(\"...answer here...\").concat(question_right_part), response: response.val(), RT: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); }, self_paced_reading: function(config, CT, magpie, answer_container_generator, startingTime){ const sentenceList = config.data[CT].sentence.trim().split(\" | \"); let spaceCounter = 0; let wordList; let readingTimes = []; // wordPos \"next\" or \"same\", if \"next\" words appear next to each other, if \"same\" all words appear at the same place // default: \"next\" let wordPos = config.data[CT].wordPos === undefined ? \"next\" : config.data[CT].wordPos; let showNeighbor = wordPos === \"next\"; // underline \"words\", \"sentence\" or \"none\", if \"words\" every word gets underlined, if \"sentence\" the sentence gets // underlined, if \"none\" there is no underline // default: \"words\" let underline = config.data[CT].underline === undefined ? \"words\" : config.data[CT].underline; let not_underline = underline === \"none\"; let one_line = underline === \"sentence\"; // shows the sentence word by word on SPACE press const handle_key_press = function(e) { if (e.which === 32 && spaceCounter < sentenceList.length) { if (showNeighbor) { wordList[spaceCounter].classList.remove(\"spr-word-hidden\"); } else { $(\".magpie-spr-sentence\").html(`<span class='spr-word'>${sentenceList[spaceCounter]}</span>`); if (not_underline){ $('.magpie-spr-sentence .spr-word').addClass('no-line'); } } if (spaceCounter === 0) { $(\".magpie-help-text\").addClass(\"magpie-invisible\"); } if (spaceCounter > 0 && showNeighbor) { wordList[spaceCounter - 1].classList.add(\"spr-word-hidden\"); } readingTimes.push(Date.now()); spaceCounter++; } else if (e.which === 32 && spaceCounter === sentenceList.length) { if (showNeighbor) { wordList[spaceCounter - 1].classList.add(\"spr-word-hidden\"); } else { $(\".magpie-spr-sentence\").html(\"\"); } $(\".magpie-view\").append(answer_container_generator(config, CT)); $(\"input[name=answer]\").on(\"change\", function() { const RT = Date.now() - startingTime; let reactionTimes = readingTimes .reduce((result, current, idx) => { return result.concat( readingTimes[idx + 1] - readingTimes[idx] ); }, []) .filter((item) => isNaN(item) === false); let trial_data = { trial_name: config.name, trial_number: CT + 1, response: $(\"input[name=answer]:checked\").val(), reaction_times: reactionTimes, time_spent: RT }; trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); magpie.trial_data.push(trial_data); magpie.findNextView(); }); readingTimes.push(Date.now()); spaceCounter++; } }; // shows the help text $(\".magpie-help-text\").removeClass(\"magpie-nodisplay\"); if (showNeighbor) { // creates the sentence sentenceList.map((word) => { $(\".magpie-spr-sentence\").append( `<span class='spr-word spr-word-hidden'>${word}</span>` ); }); // creates an array of spr word elements wordList = $(\".spr-word\").toArray(); } if (not_underline){ $('.magpie-spr-sentence .spr-word').addClass('no-line'); } if (one_line){ $('.magpie-spr-sentence .spr-word').addClass('one-line'); } // attaches an eventListener to the body for space $(\"body\").on(\"keydown\", handle_key_press); } };","title":"Handle response functions"},{"location":"01_designing_experiments/03_custom_views/#defining-a-custom-view-from-scratch","text":"You can also define a custom view from scratch. To do this, create a view template, ideally in file 03_custom_views_templates.js . A view template gets a config object information as input (with relevant information, e.g., URLs for pictures, text to show on each trial etc.). The view template function then returns a view. Here's a basic scaffolding of a view template: const custom_view_template = function(config) { const view = { name: config.name, CT: 0, trials: config.trials, // The render functions gets the magpie object as well as the current trial in view counter as input render: function (CT, magpie) { // Here, you can do whatever you want, eventually you should call magpie.findNextView() // to proceed to the next view and if it is an trial type view, // you should save the trial information with magpie.trial_data.push(trial_data) } }; // We have to return the view, so that it can be used in 05_views.js return view; }; A view is an object, that obligatorily has the properties: name : the view's name CT : the view's current trial (the counter of how many times this view occurred in the experiment, initialized to 0) trials : the maximum number of times this view is repeated render : a function that is called to create each trial of the view The most important part is the render function. It gets CT and the magpie-object itself as input. has to call magpie.findNextView() eventually to proceed to the next view (or the next trial in this view). If data is to be saved from any given trial, you would need to collect the data as an object, e.g., named trial_data and store it for later output by calling magpie.trial_data.push(trial_data) . Here's a full example from the showroom : // In this view the user can click on one of two buttons const custom_press_a_button = function(config) { const view = { name: config.name, CT: 0, trials: config.trials, // The render functions gets the magpie object as well as the current trial in view counter as input render: function (CT, magpie) { // Here, you can do whatever you want, eventually you should call magpie.findNextView() // to proceed to the next view and if it is an trial type view, // you should save the trial information with magpie.trial_data.push(trial_data) // Normally, you want to display some kind of html, to do this you append your html to the main element // You could use one of our predefined html-templates, with (magpie.)stimulus_container_generators[\"<view_name>\"](config, CT) $(\"main\").html(`<div class='magpie-view'> <h1 class='magpie-view-title'>Click on one of the buttons!</h1> <button id=\"first\" class='magpie-view-button'>First Button</button> <button id=\"second\" class='magpie-view-button'>Second Button</button> </div>`); // This function will handle the response const handle_click = function(e) { // We will just save the response and continue to the next view let trial_data = { trial_name: config.name, trial_number: CT + 1, response: e.target.id }; // Often it makes sense to also save the config information // trial_data = magpieUtils.view.save_config_trial_data(config.data[CT], trial_data); // Here, we save the trial_data magpie.trial_data.push(trial_data); // Now, we will continue with the next view magpie.findNextView(); }; // We will add the handle_click functions to both buttons $('#first').on(\"click\", handle_click); $('#second').on(\"click\", handle_click); // That's everything for this view } }; // We have to return the view, so that it can be used in 05_views.js return view; };","title":"Defining a custom view from scratch"},{"location":"01_designing_experiments/03_miscellaneous/","text":"Progress bars progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displayed. Global information","title":"Progress bars"},{"location":"01_designing_experiments/03_miscellaneous/#progress-bars","text":"progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ 'forced_choice', // 6 trials 'dropdown_choice' // 10 trials 'slider_rating', // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displayed.","title":"Progress bars"},{"location":"01_designing_experiments/03_miscellaneous/#global-information","text":"","title":"Global information"},{"location":"01_designing_experiments/04_lifecycles_hooks/","text":"Life cycles and hooks All trial views have a fixed life cycle that you can use to manipulate the timing of events during a trial. You can insert custom functions, so-called 'hooks' to massage template views into style. Life cycles All the trial views go through the following steps. pause step :: show a blank screen for specified time enable by passing pause: number (in miliseconds) defaults to pause: 0 shows nothing but a blank screen and the QUD if there is such fixation point step :: show fixation cross in the middle where the stimulus appears for specified time enabled by setting fix_duration: number (in miliseconds) defaults to fix_duration: 0 shows a cross in the middle of the stimulus and the QUD if there is such stimulus shown step :: stimulus appears stimulus hidden step :: hides the stimulus from the screen set by passing stim_duration: number (in miliseconds) defaults to stim_duration: Infinity hide the stimulus when SPACE gets pressed with stim_duration: 'space' skip this step by not defining stim_duration response enabled step :: the participant can interact with the view (respond, read the sentence etc.** Example Suppose you want to add a 1000 ms inter-stimulus break between two trials and show a fixation cross for 250 ms. You could realize this when instantiating your view like this: const forced_choice_2A = magpieViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, pause: 1000, fix_duration: 250 }); Hooks For minor customization of the template views, you can create functions, ideally in file 02_custom_functions.js and hook these functions to specific steps in the life cycle of a trial view. The following hooks exist where your custom functions could attach: after the pause is finished enable with hook.after_pause: _function_ after the fixation point hides enable with hook.after_fix_point: _function_ after the stimulus is shown enable with hook.after_stim_shown: _function_ after the stimulus hides enable with hook.after_stim_hidden: _function_ after the interactions are enabled enable with hook.after_response_enabled: _function_ Your custom functions get the trial data for each trial view and next as arguments. You can use the data if you need to. To proceed to the next step of the lifecycle, you have to call next() Full lifecycle - hook sample pause shows pause finishes after_pause function called fixation point shows fixation point disappears after_fix_point function called stimulus shows after_stim_shown function called stimlus hides after_stim_hidden function called response is enabled after_response_enabled function called Example: response check Imagine you want to tell the participants whether their choice was right or wrong, e.g., during practice trials. We could realize this with a function which checks the answer for correctness which is hooked to the \"response-enabled step\". Of course, your data for each trial needs to include the information which answer is correct. For the Departure-Point example, we could add this information to 04_trials.js like so: forced_choice: [ { question: \"What's on the bread?\", picture: \"images/question_mark_02.png\", option1: 'jam', option2: 'ham', correct: 'jam' // which option is correct? }, { question: \"What's the weather like?\", picture: \"images/weather.jpg\", option1: \"shiny\", option2: \"rainbow\", correct: \"shiny\" // which option is correct? } ] We then define the function to be hooked, ideally in file 02_custom_functions.js : // compares the chosen answer to the value of `option1` check_response = function(data, next) { $('input[name=answer]').on('change', function(e) { if (e.target.value === data.correct) { alert('Your answer is correct! Yey!'); } else { alert('Sorry, this answer is incorrect :( The correct answer was ' + data.correct); } next(); }) } We then add this function to be called after the relevant step when creating the relevant view: const forced_choice_2A = magpieViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, hook: { after_response_enabled: check_response } });","title":"Life cycles and hooks"},{"location":"01_designing_experiments/04_lifecycles_hooks/#life-cycles-and-hooks","text":"All trial views have a fixed life cycle that you can use to manipulate the timing of events during a trial. You can insert custom functions, so-called 'hooks' to massage template views into style.","title":"Life cycles and hooks"},{"location":"01_designing_experiments/04_lifecycles_hooks/#life-cycles","text":"All the trial views go through the following steps. pause step :: show a blank screen for specified time enable by passing pause: number (in miliseconds) defaults to pause: 0 shows nothing but a blank screen and the QUD if there is such fixation point step :: show fixation cross in the middle where the stimulus appears for specified time enabled by setting fix_duration: number (in miliseconds) defaults to fix_duration: 0 shows a cross in the middle of the stimulus and the QUD if there is such stimulus shown step :: stimulus appears stimulus hidden step :: hides the stimulus from the screen set by passing stim_duration: number (in miliseconds) defaults to stim_duration: Infinity hide the stimulus when SPACE gets pressed with stim_duration: 'space' skip this step by not defining stim_duration response enabled step :: the participant can interact with the view (respond, read the sentence etc.** Example Suppose you want to add a 1000 ms inter-stimulus break between two trials and show a fixation cross for 250 ms. You could realize this when instantiating your view like this: const forced_choice_2A = magpieViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, pause: 1000, fix_duration: 250 });","title":"Life cycles"},{"location":"01_designing_experiments/04_lifecycles_hooks/#hooks","text":"For minor customization of the template views, you can create functions, ideally in file 02_custom_functions.js and hook these functions to specific steps in the life cycle of a trial view. The following hooks exist where your custom functions could attach: after the pause is finished enable with hook.after_pause: _function_ after the fixation point hides enable with hook.after_fix_point: _function_ after the stimulus is shown enable with hook.after_stim_shown: _function_ after the stimulus hides enable with hook.after_stim_hidden: _function_ after the interactions are enabled enable with hook.after_response_enabled: _function_ Your custom functions get the trial data for each trial view and next as arguments. You can use the data if you need to. To proceed to the next step of the lifecycle, you have to call next() Full lifecycle - hook sample pause shows pause finishes after_pause function called fixation point shows fixation point disappears after_fix_point function called stimulus shows after_stim_shown function called stimlus hides after_stim_hidden function called response is enabled after_response_enabled function called Example: response check Imagine you want to tell the participants whether their choice was right or wrong, e.g., during practice trials. We could realize this with a function which checks the answer for correctness which is hooked to the \"response-enabled step\". Of course, your data for each trial needs to include the information which answer is correct. For the Departure-Point example, we could add this information to 04_trials.js like so: forced_choice: [ { question: \"What's on the bread?\", picture: \"images/question_mark_02.png\", option1: 'jam', option2: 'ham', correct: 'jam' // which option is correct? }, { question: \"What's the weather like?\", picture: \"images/weather.jpg\", option1: \"shiny\", option2: \"rainbow\", correct: \"shiny\" // which option is correct? } ] We then define the function to be hooked, ideally in file 02_custom_functions.js : // compares the chosen answer to the value of `option1` check_response = function(data, next) { $('input[name=answer]').on('change', function(e) { if (e.target.value === data.correct) { alert('Your answer is correct! Yey!'); } else { alert('Sorry, this answer is incorrect :( The correct answer was ' + data.correct); } next(); }) } We then add this function to be called after the relevant step when creating the relevant view: const forced_choice_2A = magpieViews.view_generator(\"key_press\", { trials: trial_info.forced_choice.length, name: 'forced_choice_2A', data: trial_info.forced_choice, hook: { after_response_enabled: check_response } });","title":"Hooks"},{"location":"01_designing_experiments/05_canvas/","text":"Canvas Each magpie trial type view can use the magpie canvas api to create a picture of elements in the trial view. magpie provides three types of element placement: random placement grid placement split grid placement How to use magpie canvas To generate a picture of shapes, all you need is to have canvas object with some properties in the data your views use. For example: let trials = [ ..., { question: \"Are there any blue squares on the screen?\", option1: 'yes', option2: 'no', canvas: { focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } }, ... ]; Data format obligatory properties sort - the way the elements are arranged on the canvas. sort: 'random' - randomly placed on the canvas. start_with does not have an effect with this arrangement method; sort: 'grid' - placed in a grid. Uses canvas.canvas.rows ; sort: 'split_grid' - placed in a grid that is split in the middle. elemSize - the size of the element's shapes (in pixels). total - the total elements that are drawn on the canvas. focalColor - the color of the focal elements. focalNumber - the number of focal elements wanted on the canvas. focalShape - the shape of the foca elements (can be 'triangle', 'circle' or 'square') otherColor - the color of the other elements otherShape - the shape of the elements (can be 'triangle', 'circle' or 'square') The number of the other elements is total - focal.number optional properties Grid placement and split Grid Placement extra properties rows the number of grid rows. Placed in one row of not given. start_with - the grid and split_grid coordinates are generated from left to right. By default first the focal elements are placed on the canvas so they always appear on the left unless start_with is set to 'other' start_with: 'focal' : places the focal shapes first (from left to right) not set start_with places the focal shapes first (from left to right) start_with: 'other' : places the other shapes first (from left to right) Split Grid extra properties gap - the gap between the two sides. The default gap is 1.5 * elemSize direction - the direction in which the elements are placed. Set to 'row' if not given. 'row' - in a row, starting from left to right, ignoring the gap between the two sides; 'side_row' - in a row starting from left to right, not ignoring the gap, i.e. first finishes with the left side and then moves to the right; 'column' - in a column, starting from top left. canvas element settings You can add a canvasSettings object to your canvas if you want to set the height, width and background of the canvas. for example: canvas: { canvasSettings: { height: 600, width: 800, backrgound: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } If not passed the canvas's - height is 300 (300px) - width is 500 (500px) - background is 'white' Examples canvas: { canvasSettings: { background: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 4, otherShape: 'circle', otherColor: 'white', sort: 'split_grid', rows: 4, direction: 'side_row', elemSize: 30, total: 10 } // gap is default (1.5 * elemSize) // start_with is default (focal elem) canvas: { canvasSettings: { height: 500, width: 700 }, focalColor: 'blue', focalShape: 'circle', focalNumber: 25, otherShape: 'circle', otherColor: 'green', sort: 'random', elemSize: 10, total: 100 } // the canvas size is increased to fit 100 elements canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 1, otherShape: 'triangle', otherColor: 'green', sort: 'random', elemSize: 30, total: 10 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', start_with: 'other', rows: 2, direction: 'side_row', elemSize: 30, total: 16 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, elemSize: 30, total: 16 } // the default direction is 'row' canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 10, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, direction: 'column' elemSize: 30, total: 16 } // direction is default ('row') // start_with is default (focal elem) canvas: { focalColor: 'grey', focalShape: 'circle', focalNumber: 6, otherShape: 'square', otherColor: 'blue', sort: 'grid', rows: 3, elemSize: 30, total: 18 } // start_with is default (focal elem)","title":"Canvas"},{"location":"01_designing_experiments/05_canvas/#canvas","text":"Each magpie trial type view can use the magpie canvas api to create a picture of elements in the trial view. magpie provides three types of element placement: random placement grid placement split grid placement","title":"Canvas"},{"location":"01_designing_experiments/05_canvas/#how-to-use-magpie-canvas","text":"To generate a picture of shapes, all you need is to have canvas object with some properties in the data your views use. For example: let trials = [ ..., { question: \"Are there any blue squares on the screen?\", option1: 'yes', option2: 'no', canvas: { focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } }, ... ];","title":"How to use magpie canvas"},{"location":"01_designing_experiments/05_canvas/#data-format","text":"","title":"Data format"},{"location":"01_designing_experiments/05_canvas/#obligatory-properties","text":"sort - the way the elements are arranged on the canvas. sort: 'random' - randomly placed on the canvas. start_with does not have an effect with this arrangement method; sort: 'grid' - placed in a grid. Uses canvas.canvas.rows ; sort: 'split_grid' - placed in a grid that is split in the middle. elemSize - the size of the element's shapes (in pixels). total - the total elements that are drawn on the canvas. focalColor - the color of the focal elements. focalNumber - the number of focal elements wanted on the canvas. focalShape - the shape of the foca elements (can be 'triangle', 'circle' or 'square') otherColor - the color of the other elements otherShape - the shape of the elements (can be 'triangle', 'circle' or 'square') The number of the other elements is total - focal.number","title":"obligatory properties"},{"location":"01_designing_experiments/05_canvas/#optional-properties","text":"","title":"optional properties"},{"location":"01_designing_experiments/05_canvas/#grid-placement-and-split-grid-placement-extra-properties","text":"rows the number of grid rows. Placed in one row of not given. start_with - the grid and split_grid coordinates are generated from left to right. By default first the focal elements are placed on the canvas so they always appear on the left unless start_with is set to 'other' start_with: 'focal' : places the focal shapes first (from left to right) not set start_with places the focal shapes first (from left to right) start_with: 'other' : places the other shapes first (from left to right)","title":"Grid placement and split Grid Placement extra properties"},{"location":"01_designing_experiments/05_canvas/#split-grid-extra-properties","text":"gap - the gap between the two sides. The default gap is 1.5 * elemSize direction - the direction in which the elements are placed. Set to 'row' if not given. 'row' - in a row, starting from left to right, ignoring the gap between the two sides; 'side_row' - in a row starting from left to right, not ignoring the gap, i.e. first finishes with the left side and then moves to the right; 'column' - in a column, starting from top left.","title":"Split Grid extra properties"},{"location":"01_designing_experiments/05_canvas/#canvas-element-settings","text":"You can add a canvasSettings object to your canvas if you want to set the height, width and background of the canvas. for example: canvas: { canvasSettings: { height: 600, width: 800, backrgound: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 23, otherShape: 'square', otherColor: 'red', sort: 'random', elemSize: 30, total: 40 } If not passed the canvas's - height is 300 (300px) - width is 500 (500px) - background is 'white'","title":"canvas element settings"},{"location":"01_designing_experiments/05_canvas/#examples","text":"canvas: { canvasSettings: { background: 'grey' }, focalColor: 'black', focalShape: 'circle', focalNumber: 4, otherShape: 'circle', otherColor: 'white', sort: 'split_grid', rows: 4, direction: 'side_row', elemSize: 30, total: 10 } // gap is default (1.5 * elemSize) // start_with is default (focal elem) canvas: { canvasSettings: { height: 500, width: 700 }, focalColor: 'blue', focalShape: 'circle', focalNumber: 25, otherShape: 'circle', otherColor: 'green', sort: 'random', elemSize: 10, total: 100 } // the canvas size is increased to fit 100 elements canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 1, otherShape: 'triangle', otherColor: 'green', sort: 'random', elemSize: 30, total: 10 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', start_with: 'other', rows: 2, direction: 'side_row', elemSize: 30, total: 16 } canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 8, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, elemSize: 30, total: 16 } // the default direction is 'row' canvas: { focalColor: 'red', focalShape: 'circle', focalNumber: 10, otherShape: 'triangle', otherColor: 'blue', sort: 'split_grid', rows: 4, gap: 200, direction: 'column' elemSize: 30, total: 16 } // direction is default ('row') // start_with is default (focal elem) canvas: { focalColor: 'grey', focalShape: 'circle', focalNumber: 6, otherShape: 'square', otherColor: 'blue', sort: 'grid', rows: 3, elemSize: 30, total: 18 } // start_with is default (focal elem)","title":"Examples"},{"location":"01_designing_experiments/06_complex_experiments/","text":"","title":"06 complex experiments"},{"location":"01_designing_experiments/06_progress_bars/","text":"Progress bars _magpie provides the option to include progress bars in selected views. For example, when you have defined views for variables practice and main , you can include progress bars for these views by specifying this information during the creation of the _magpie object, like so: $(\"document\").ready(function() { magpieInit({ ... progress_bar: { in: [ practice.name, main.name ], // only the practice and the main view will have progress bars in this experiment style: \"chunks\", // there will be two chunks - one for the practice and one for the main view width: 100 // each one of the two chunks will be 100 pixels long } }); }); Notice that the array progress.in requires not the variables, but the view's names (as strings). It is therefore important that each view receives its own unique name. You can use one of the following 3 styles (see pictues below): separate - shows a single bar which tracks progress within the current view default - shows a single bar which tracks progress within the whole experiment (all views designated for progress tracking) chunks - shows multiple bars, one for each progress-tracked view Use progress_bar.width to set the width (in pixels** of the progress bars. Examples progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displyed.","title":"Progress bars"},{"location":"01_designing_experiments/06_progress_bars/#progress-bars","text":"_magpie provides the option to include progress bars in selected views. For example, when you have defined views for variables practice and main , you can include progress bars for these views by specifying this information during the creation of the _magpie object, like so: $(\"document\").ready(function() { magpieInit({ ... progress_bar: { in: [ practice.name, main.name ], // only the practice and the main view will have progress bars in this experiment style: \"chunks\", // there will be two chunks - one for the practice and one for the main view width: 100 // each one of the two chunks will be 100 pixels long } }); }); Notice that the array progress.in requires not the variables, but the view's names (as strings). It is therefore important that each view receives its own unique name. You can use one of the following 3 styles (see pictues below): separate - shows a single bar which tracks progress within the current view default - shows a single bar which tracks progress within the whole experiment (all views designated for progress tracking) chunks - shows multiple bars, one for each progress-tracked view Use progress_bar.width to set the width (in pixels** of the progress bars. Examples progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"default\", width: 120 // 120 pixels } // 20 trials overall, each trial fills 10 pixels (120/20) part of the progress bar progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"separate\", width: 120 // 120 pixels } // 20 trials overall, each trial fills (120/total trials) pixels part of the progress bar. Each type of view has a separate progress bar. progress_bar: { in: [ forced_choice.name, // 6 trials dropdown_choice.name // 10 trials slider_rating.name, // 4 trials ], style: \"chunks\", width: 60 // 60 pixels } // 20 trials overall, each trial fills part of its corresponding chunk. Each type of view has a separate progress bar and all progress bars are displyed.","title":"Progress bars"},{"location":"02_using_the_server_app/01_installation/","text":"Installation You can install _magpie on a server for online use or locally on your machine. We explain here how to use Heroku as a hosting service for online use, and how to set up the server app locally. Installation on Heroku The _magpie server app can be hosted on any hosting service or your own server. We here describe the process for installation on Heroku . Heroku makes it easy to deploy an web app without having to manually manage the infrastructure. It has a free starter tier, which should be sufficient for the purpose of running experiments. There is an official guide on how to deploy the Phoenix framework on Heroku. The deployment procedure is based on this guide, but differs in some places. {:start=\"0\"} 0. Ensure that you have the Phoenix Framework installed and working. However, if you just want to deploy this server and do no development work/change on it at all, you may skip this step. Ensure that you have a Heroku account already, and have the Heroku CLI installed and working on your computer. Ensure you have Git installed. Clone this git repo with git clone https://github.com/magpie-ea/magpie-backend or git clone git@github.com:magpie-ea/magpie-backend.git . cd into the project directory just cloned from your Terminal (or cmd.exe on Windows). Run heroku create --buildpack \"https://github.com/HashNuke/heroku-buildpack-elixir.git\" Run heroku buildpacks:add https://github.com/gjaldon/heroku-buildpack-phoenix-static.git (N.B.: Although the command line output tells you to run git push heroku master , don't do it yet.) You may want to change the application name instead of using the default name. In that case, run heroku apps:rename newname . Edit line 17 of the file config/prod.exs . Replace the part magpie-backend.herokuapp.com after host with the app name (shown when you first ran heroku create , e.g. mysterious-meadow-6277.herokuapp.com , or the app name that you set at step 6, e.g. newname.herokuapp.com ). You shouldn't need to modify anything else. Ensure that you're at the top-level project directory. Run heroku addons:create heroku-postgresql:hobby-dev heroku config:set POOL_SIZE=18 Run mix deps.get then mix phx.gen.secret . Then run heroku config:set SECRET_KEY_BASE=\"OUTPUT\" , where OUTPUT should be the output of the mix phx.gen.secret step. Note: If you don't have the Phoenix framework installed on your computer, you may choose to use some other random generator for this task, which essentially asks for a random 64-character secret. On Mac and Linux, you may run openssl rand -base64 64 . Or you may use an online password generator such as the one offered by LastPass . Run git add config/prod.exs , then git commit -m \"Set app URL\" . Don't forget to set the environment variables AUTH_USERNAME and AUTH_PASSWORD , either in the Heroku web interface or via the command line, i.e. heroku config:set AUTH_USERNAME=\"your_username\" heroku config:set AUTH_PASSWORD=\"your_password\" Run git push heroku master . This will push the repo to the git remote at Heroku (instead of the original remote at Github), and deploy the app. Run heroku run \"POOL_SIZE=2 mix ecto.migrate\" Now, heroku open should open the frontpage of the app. Installation locally The first-time installation requires an internet connection. After it is finished, the server can be launched offline. (Note that for local deployment, the default username is default and the default password is password . You can change them in config/dev.exs .) First time installation To begin with, install Docker from https://docs.docker.com/install/ . You may have to launch the application once in order to let it install its command line tools. Verify the installation by typing docker version in a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows). Note: - Although the Docker app on Windows and Mac asks for login credentials to Docker Hub, they are not needed for local deployment. You can proceed without creating any Docker account/logging in. - Linux users would need to install docker-compose separately. See relevant instructions here . Once you have Docker installed, follow these steps: Ensure you have Git installed. Clone the server repo with git clone https://github.com/magpie-ea/magpie-backend.git or git clone git@github.com:magpie-ea/magpie-backend.git . Open a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows), cd into the project directory just cloned via git. For the first-time setup, run in the terminal docker volume create --name magpie-app-volume -d local docker volume create --name magpie-db-volume -d local docker-compose run --rm web bash -c \"mix deps.get && npm install && node node_modules/brunch/bin/brunch build && mix ecto.migrate\" Deployment After first-time installation, you can launch a local server instance which allows you to manage the experiments in your browser and stores the results. Run docker-compose up to launch the application every time you want to run the server. Wait until the line web_1 | [info] Running magpie-backend.Endpoint with Cowboy using http://0.0.0.0:4000 appears in the terminal. Visit localhost:4000 in your browser. You should see the server up and running. Note: Windows 7 users who installed Docker Machine might need to find out the IP address used by docker-machine instead of localhost . See Docker documentation for details. Use Ctrl + C to shut down the server. Note that the database for storing experiment results is stored at /var/lib/docker/volumes/magpie-db-volume/_data folder by default. As long as this folder is preserved, experiment results should persist as well.","title":"Installation"},{"location":"02_using_the_server_app/01_installation/#installation","text":"You can install _magpie on a server for online use or locally on your machine. We explain here how to use Heroku as a hosting service for online use, and how to set up the server app locally.","title":"Installation"},{"location":"02_using_the_server_app/01_installation/#installation-on-heroku","text":"The _magpie server app can be hosted on any hosting service or your own server. We here describe the process for installation on Heroku . Heroku makes it easy to deploy an web app without having to manually manage the infrastructure. It has a free starter tier, which should be sufficient for the purpose of running experiments. There is an official guide on how to deploy the Phoenix framework on Heroku. The deployment procedure is based on this guide, but differs in some places. {:start=\"0\"} 0. Ensure that you have the Phoenix Framework installed and working. However, if you just want to deploy this server and do no development work/change on it at all, you may skip this step. Ensure that you have a Heroku account already, and have the Heroku CLI installed and working on your computer. Ensure you have Git installed. Clone this git repo with git clone https://github.com/magpie-ea/magpie-backend or git clone git@github.com:magpie-ea/magpie-backend.git . cd into the project directory just cloned from your Terminal (or cmd.exe on Windows). Run heroku create --buildpack \"https://github.com/HashNuke/heroku-buildpack-elixir.git\" Run heroku buildpacks:add https://github.com/gjaldon/heroku-buildpack-phoenix-static.git (N.B.: Although the command line output tells you to run git push heroku master , don't do it yet.) You may want to change the application name instead of using the default name. In that case, run heroku apps:rename newname . Edit line 17 of the file config/prod.exs . Replace the part magpie-backend.herokuapp.com after host with the app name (shown when you first ran heroku create , e.g. mysterious-meadow-6277.herokuapp.com , or the app name that you set at step 6, e.g. newname.herokuapp.com ). You shouldn't need to modify anything else. Ensure that you're at the top-level project directory. Run heroku addons:create heroku-postgresql:hobby-dev heroku config:set POOL_SIZE=18 Run mix deps.get then mix phx.gen.secret . Then run heroku config:set SECRET_KEY_BASE=\"OUTPUT\" , where OUTPUT should be the output of the mix phx.gen.secret step. Note: If you don't have the Phoenix framework installed on your computer, you may choose to use some other random generator for this task, which essentially asks for a random 64-character secret. On Mac and Linux, you may run openssl rand -base64 64 . Or you may use an online password generator such as the one offered by LastPass . Run git add config/prod.exs , then git commit -m \"Set app URL\" . Don't forget to set the environment variables AUTH_USERNAME and AUTH_PASSWORD , either in the Heroku web interface or via the command line, i.e. heroku config:set AUTH_USERNAME=\"your_username\" heroku config:set AUTH_PASSWORD=\"your_password\" Run git push heroku master . This will push the repo to the git remote at Heroku (instead of the original remote at Github), and deploy the app. Run heroku run \"POOL_SIZE=2 mix ecto.migrate\" Now, heroku open should open the frontpage of the app.","title":"Installation on Heroku"},{"location":"02_using_the_server_app/01_installation/#installation-locally","text":"The first-time installation requires an internet connection. After it is finished, the server can be launched offline. (Note that for local deployment, the default username is default and the default password is password . You can change them in config/dev.exs .)","title":"Installation locally"},{"location":"02_using_the_server_app/01_installation/#first-time-installation","text":"To begin with, install Docker from https://docs.docker.com/install/ . You may have to launch the application once in order to let it install its command line tools. Verify the installation by typing docker version in a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows). Note: - Although the Docker app on Windows and Mac asks for login credentials to Docker Hub, they are not needed for local deployment. You can proceed without creating any Docker account/logging in. - Linux users would need to install docker-compose separately. See relevant instructions here . Once you have Docker installed, follow these steps: Ensure you have Git installed. Clone the server repo with git clone https://github.com/magpie-ea/magpie-backend.git or git clone git@github.com:magpie-ea/magpie-backend.git . Open a terminal (e.g., the Terminal app on MacOS or cmd.exe on Windows), cd into the project directory just cloned via git. For the first-time setup, run in the terminal docker volume create --name magpie-app-volume -d local docker volume create --name magpie-db-volume -d local docker-compose run --rm web bash -c \"mix deps.get && npm install && node node_modules/brunch/bin/brunch build && mix ecto.migrate\"","title":"First time installation"},{"location":"02_using_the_server_app/01_installation/#deployment","text":"After first-time installation, you can launch a local server instance which allows you to manage the experiments in your browser and stores the results. Run docker-compose up to launch the application every time you want to run the server. Wait until the line web_1 | [info] Running magpie-backend.Endpoint with Cowboy using http://0.0.0.0:4000 appears in the terminal. Visit localhost:4000 in your browser. You should see the server up and running. Note: Windows 7 users who installed Docker Machine might need to find out the IP address used by docker-machine instead of localhost . See Docker documentation for details. Use Ctrl + C to shut down the server. Note that the database for storing experiment results is stored at /var/lib/docker/volumes/magpie-db-volume/_data folder by default. As long as this folder is preserved, experiment results should persist as well.","title":"Deployment"},{"location":"02_using_the_server_app/02_use/","text":"Use After installation you can visit the server app in a browser, with the username and password you previously specified. For Heroku deployment, you may do so by running heroku open in the command line or find the app URL in your Heroku account. For local deployment, the URL is by default http://localhost:4000. There is an example demo of the server app available at https://magpie-demo.herokuapp.com . Managing experiments The server app shows a list of experiments whose data may be stored in a database. It shows the experiments ID, its name, its author, the number of submissions retrieved so far, date information, as well as whether the experiment is currently active or not. If an experiment is set to be active, it allows further submissions to be recorded in the database. The server app allows you to retrieve the data for an experiment from the database. Simply click on the button \"Retrieve CSV\" to download a CSV-file with the data collected so far. To delete an experiment, click the \"Delete\" button. Always make sure that you have recovered all necessary data from that experiment; otherwise your data collected so far might be irrevocably lost. You can also edit an experiment with the \"Edit\" button. You can change information about the experiment on the edit-screen. You can also toggle whether the experiment is active or not. You can set a maximum number of submissions after which the experiment automatically toggles its activity status off. Any submission made by a participant to a non-active experiment is just lost and will not be recorded. This is to protect your database from pollution or attacks, but if used unwisely could also cause you loss of relevant data. Creating new experiments Click on the \"New\" button under \"Manage Experiments\" to set up a new data base for your experiment. The interface for creating a new experiment is very similar to editing an existing experiment. Importantly, you need to give some required information about a new experiment (name and author). If you want to use dynamic retrieval of experiment data ( documentation pending ), you must specify which fields should be available to be retrieved by your API calls. This allows you to expose only the relevant fields, since the dynamic retrieval API is not password protected by default. After you have created your experiment, there are two pieces of information that are important for later use. When you specify the deploy information , you must supply the ID which the server app allocates to your experiment and you must specify the URL (possibly local) of the server app itself. You find these pieces of information when you click on \"Edit\" for your newly created experiment. You need to specify the ID in field experimentID and the server URL for submissions without the ID in the field serverAppURL . So, in the case above, you would initialize your experiment with the following information: magpieInit({ ... deploy: { experimentID: \"1\", serverAppURL: \"https://magpie-demo.herokuapp.com/api/submit_experiment/\", ... } ... });","title":"Use"},{"location":"02_using_the_server_app/02_use/#use","text":"After installation you can visit the server app in a browser, with the username and password you previously specified. For Heroku deployment, you may do so by running heroku open in the command line or find the app URL in your Heroku account. For local deployment, the URL is by default http://localhost:4000. There is an example demo of the server app available at https://magpie-demo.herokuapp.com .","title":"Use"},{"location":"02_using_the_server_app/02_use/#managing-experiments","text":"The server app shows a list of experiments whose data may be stored in a database. It shows the experiments ID, its name, its author, the number of submissions retrieved so far, date information, as well as whether the experiment is currently active or not. If an experiment is set to be active, it allows further submissions to be recorded in the database. The server app allows you to retrieve the data for an experiment from the database. Simply click on the button \"Retrieve CSV\" to download a CSV-file with the data collected so far. To delete an experiment, click the \"Delete\" button. Always make sure that you have recovered all necessary data from that experiment; otherwise your data collected so far might be irrevocably lost. You can also edit an experiment with the \"Edit\" button. You can change information about the experiment on the edit-screen. You can also toggle whether the experiment is active or not. You can set a maximum number of submissions after which the experiment automatically toggles its activity status off. Any submission made by a participant to a non-active experiment is just lost and will not be recorded. This is to protect your database from pollution or attacks, but if used unwisely could also cause you loss of relevant data.","title":"Managing experiments"},{"location":"02_using_the_server_app/02_use/#creating-new-experiments","text":"Click on the \"New\" button under \"Manage Experiments\" to set up a new data base for your experiment. The interface for creating a new experiment is very similar to editing an existing experiment. Importantly, you need to give some required information about a new experiment (name and author). If you want to use dynamic retrieval of experiment data ( documentation pending ), you must specify which fields should be available to be retrieved by your API calls. This allows you to expose only the relevant fields, since the dynamic retrieval API is not password protected by default. After you have created your experiment, there are two pieces of information that are important for later use. When you specify the deploy information , you must supply the ID which the server app allocates to your experiment and you must specify the URL (possibly local) of the server app itself. You find these pieces of information when you click on \"Edit\" for your newly created experiment. You need to specify the ID in field experimentID and the server URL for submissions without the ID in the field serverAppURL . So, in the case above, you would initialize your experiment with the following information: magpieInit({ ... deploy: { experimentID: \"1\", serverAppURL: \"https://magpie-demo.herokuapp.com/api/submit_experiment/\", ... } ... });","title":"Creating new experiments"},{"location":"03_deploying_experiments/01_configuration/","text":"Deploy Configuration The deployment method determines how to ship your experiment to your participants (if at all) and how to process its data. For development, you will want to use the debug mode, which shows the data collected from the current execution of the experiment in the browser at the end of the experiment. To actually collect data from participants, _magpie uses the magpie server app to store the data in a data base (and possibly to manage allocation of participants to different variants of your experiment). You therefore need to have a running instance of the server app, either online or locally, as described in the server app section on installation . There are three deployment modes to collect data via the _magpie server app (to be detailed below): The directLink mode allows participants to work on your experiment simply by following a link. The MTurk mode is used to recruit participants via Amazon's Mechanical Turk . The Prolific mode is used to recruit participants via Prolific . All of these methods require that you have initialized a database on the _magpie server app, as described here . You need the experimentID (a running number) which the server app creates for your experiment, as well as the URL (possibly local) of your experiment. Unless you run your experiment strictly locally on your own (lab) computer(s), you also need to launch the experiment as a website on some hosting service. A possibility for doing so is described in the section on hosting on Netlify . Changing deploy information Deployment information needs to be given during the initial creation of the _magpie-object (e.g., in file 06_main.js of the Departure Point ), by setting the properties of the deploy object, as shown below: magpieInit({ ... deploy: { experimentID: \"INSERT_A_NUMBER\", serverAppURL: \"https://magpie-demo.herokuapp.com/api/submit_experiment/\", // Possible deployment methods are: // \"debug\" and \"directLink\" // As well as \"MTurk\", \"MTurkSandbox\" and \"Prolific\" deployMethod: \"debug\", contact_email: \"YOUREMAIL@wherelifeisgreat.you\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); None of these fields matter for the debug mode. But for any of the other modes, you should specify appropriate information to the following fields: contact_email should contain an appropriate email address which will be displayed in an alert box in case of errors, so your participants can directly reach out to you. experimentID must contain the ID the _magpie server app provided for your experiment when created it online (see the section on server app use for more information). serverAppURL is the URL (possibly local) to your server app instance which handles the data (see the section on server app use for more information). prolificURL needs to be specified only if you use the Prolific deploy mode. In that case you need to enter here the return URL given to you when you create your experiment on the Prolific web site (see information below).","title":"Deploy configuration"},{"location":"03_deploying_experiments/01_configuration/#deploy-configuration","text":"The deployment method determines how to ship your experiment to your participants (if at all) and how to process its data. For development, you will want to use the debug mode, which shows the data collected from the current execution of the experiment in the browser at the end of the experiment. To actually collect data from participants, _magpie uses the magpie server app to store the data in a data base (and possibly to manage allocation of participants to different variants of your experiment). You therefore need to have a running instance of the server app, either online or locally, as described in the server app section on installation . There are three deployment modes to collect data via the _magpie server app (to be detailed below): The directLink mode allows participants to work on your experiment simply by following a link. The MTurk mode is used to recruit participants via Amazon's Mechanical Turk . The Prolific mode is used to recruit participants via Prolific . All of these methods require that you have initialized a database on the _magpie server app, as described here . You need the experimentID (a running number) which the server app creates for your experiment, as well as the URL (possibly local) of your experiment. Unless you run your experiment strictly locally on your own (lab) computer(s), you also need to launch the experiment as a website on some hosting service. A possibility for doing so is described in the section on hosting on Netlify .","title":"Deploy Configuration"},{"location":"03_deploying_experiments/01_configuration/#changing-deploy-information","text":"Deployment information needs to be given during the initial creation of the _magpie-object (e.g., in file 06_main.js of the Departure Point ), by setting the properties of the deploy object, as shown below: magpieInit({ ... deploy: { experimentID: \"INSERT_A_NUMBER\", serverAppURL: \"https://magpie-demo.herokuapp.com/api/submit_experiment/\", // Possible deployment methods are: // \"debug\" and \"directLink\" // As well as \"MTurk\", \"MTurkSandbox\" and \"Prolific\" deployMethod: \"debug\", contact_email: \"YOUREMAIL@wherelifeisgreat.you\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); None of these fields matter for the debug mode. But for any of the other modes, you should specify appropriate information to the following fields: contact_email should contain an appropriate email address which will be displayed in an alert box in case of errors, so your participants can directly reach out to you. experimentID must contain the ID the _magpie server app provided for your experiment when created it online (see the section on server app use for more information). serverAppURL is the URL (possibly local) to your server app instance which handles the data (see the section on server app use for more information). prolificURL needs to be specified only if you use the Prolific deploy mode. In that case you need to enter here the return URL given to you when you create your experiment on the Prolific web site (see information below).","title":"Changing deploy information"},{"location":"03_deploying_experiments/02_recruitment_MTurk/","text":"Recruitment via MTurk You can post a _magpie experiment as an external HIT on MTurk. If you are familiar with posting external HITs, the only thing that you need to take into account is that _magpie experiments send their collected data to the _magpie backend. So, in order to collect the data from your experiment, you would visit the _magpie backend to download a CSV file. No need to go via MTurk. If you are not familiar with posting external HITs on MTurk, here is a simple method that uses boto3 , which is a Python SDK for Amazon's Web Services (AWS). The MTurkDeployTemplate gives a full example of an experiment that uses this method. The method we propose here is easy in the sense that it might require less downloading / installing than other methods. You only need Python and the boto3 package. (But here and there are fully viable alternative methods and resources that provide additional useful information.) We assume that you have an MTurk account and that you have your AWS credentials ready at hand. (If not, see here for instructions on how to setup your account.) Download a recent version of Python (we used 3.6 at the time of writing) and install the boto3 package, e.g., using pip . Next, in your homedirectory, create the file: ~/.aws/config Fill this file with the following content, so that boto3 knows about your AWS credentials (never post this, host this or share this): [default] aws_access_key_id=YOUR_ACCESS_KEY_ID aws_secret_access_key=YOUR_SECRET_ACCESS_KEY Make sure that your _magpie experiment is ready for MTurk deployment: set the deployment method to MTurk host the experiment on a web server, e.g., using Netlify make sure you have the URL for your web-version of the experiment ready Save the following code in a file called create_HIT.py , after inserting the correct URL to your experiment and commenting in/out the relevant lines depending on whether you want a real live experiment or a test version in the sandbox. import boto3 MTURK_SANDBOX = 'https://mturk-requester-sandbox.us-east-1.amazonaws.com' mturk = boto3.client('mturk', region_name='us-east-1' # endpoint_url = MTURK_SANDBOX # include this for sandbox mode ) your_url = \"https://YOUR_URL\" # insert your URL external_question = \"\"\"<ExternalQuestion xmlns='http://mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2006-07-14/ExternalQuestion.xsd'> <ExternalURL>\"\"\" + your_url + \"\"\"</ExternalURL> <FrameHeight>600</FrameHeight> </ExternalQuestion>\"\"\" new_hit = mturk.create_hit( Title = 'Your title', Description = 'Your description', Keywords = 'some keywords', Reward = '0.5', # how much to pay MaxAssignments = 1, # how many participants LifetimeInSeconds = 172800, AssignmentDurationInSeconds = 600, AutoApprovalDelayInSeconds = 14400, Question = external_question, ) print(\"A new HIT has been created. You can preview it here:\") #print(\"https://workersandbox.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # comment in for sandbox mode print(\"https://worker.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # use this otherwise print(\"HITID = \" + new_hit['HIT']['HITId'] + \" (for your reference)\") Now execute python create_HIT.py . Make sure you note the HITid that this call returns, because you need it to further identify this experimental run when interacting with MTurk. Download file get_HIT_status.py here and use python get_HIT_status.py YOUR_HIT_ID , where YOUR_HIT_ID is the HITid returned when you posted the HIT, to learn how many workers have completed your work. Download file approve_HIT.py here and use python approve_HIT.py YOUR_HIT_ID to reimburse all workers. You can manipulate (expire, extend, ...) your HIT using boto3 as described in the boto3 documentation . For some recurrent manipulations, you can also use this web interface .","title":"Recruitment via MTurk"},{"location":"03_deploying_experiments/02_recruitment_MTurk/#recruitment-via-mturk","text":"You can post a _magpie experiment as an external HIT on MTurk. If you are familiar with posting external HITs, the only thing that you need to take into account is that _magpie experiments send their collected data to the _magpie backend. So, in order to collect the data from your experiment, you would visit the _magpie backend to download a CSV file. No need to go via MTurk. If you are not familiar with posting external HITs on MTurk, here is a simple method that uses boto3 , which is a Python SDK for Amazon's Web Services (AWS). The MTurkDeployTemplate gives a full example of an experiment that uses this method. The method we propose here is easy in the sense that it might require less downloading / installing than other methods. You only need Python and the boto3 package. (But here and there are fully viable alternative methods and resources that provide additional useful information.) We assume that you have an MTurk account and that you have your AWS credentials ready at hand. (If not, see here for instructions on how to setup your account.) Download a recent version of Python (we used 3.6 at the time of writing) and install the boto3 package, e.g., using pip . Next, in your homedirectory, create the file: ~/.aws/config Fill this file with the following content, so that boto3 knows about your AWS credentials (never post this, host this or share this): [default] aws_access_key_id=YOUR_ACCESS_KEY_ID aws_secret_access_key=YOUR_SECRET_ACCESS_KEY Make sure that your _magpie experiment is ready for MTurk deployment: set the deployment method to MTurk host the experiment on a web server, e.g., using Netlify make sure you have the URL for your web-version of the experiment ready Save the following code in a file called create_HIT.py , after inserting the correct URL to your experiment and commenting in/out the relevant lines depending on whether you want a real live experiment or a test version in the sandbox. import boto3 MTURK_SANDBOX = 'https://mturk-requester-sandbox.us-east-1.amazonaws.com' mturk = boto3.client('mturk', region_name='us-east-1' # endpoint_url = MTURK_SANDBOX # include this for sandbox mode ) your_url = \"https://YOUR_URL\" # insert your URL external_question = \"\"\"<ExternalQuestion xmlns='http://mechanicalturk.amazonaws.com/AWSMechanicalTurkDataSchemas/2006-07-14/ExternalQuestion.xsd'> <ExternalURL>\"\"\" + your_url + \"\"\"</ExternalURL> <FrameHeight>600</FrameHeight> </ExternalQuestion>\"\"\" new_hit = mturk.create_hit( Title = 'Your title', Description = 'Your description', Keywords = 'some keywords', Reward = '0.5', # how much to pay MaxAssignments = 1, # how many participants LifetimeInSeconds = 172800, AssignmentDurationInSeconds = 600, AutoApprovalDelayInSeconds = 14400, Question = external_question, ) print(\"A new HIT has been created. You can preview it here:\") #print(\"https://workersandbox.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # comment in for sandbox mode print(\"https://worker.mturk.com/mturk/preview?groupId=\" + new_hit['HIT']['HITGroupId']) # use this otherwise print(\"HITID = \" + new_hit['HIT']['HITId'] + \" (for your reference)\") Now execute python create_HIT.py . Make sure you note the HITid that this call returns, because you need it to further identify this experimental run when interacting with MTurk. Download file get_HIT_status.py here and use python get_HIT_status.py YOUR_HIT_ID , where YOUR_HIT_ID is the HITid returned when you posted the HIT, to learn how many workers have completed your work. Download file approve_HIT.py here and use python approve_HIT.py YOUR_HIT_ID to reimburse all workers. You can manipulate (expire, extend, ...) your HIT using boto3 as described in the boto3 documentation . For some recurrent manipulations, you can also use this web interface .","title":"Recruitment via MTurk"},{"location":"03_deploying_experiments/03_recruitment_Prolific/","text":"Recruitment via Prolific The following assumes that you are familiar with how to operate experiments with Prolific . Go to the Prolific website and create a new experiment. Make a note of the completion URL that is provided by Prolific. Enter the completion URL in the field prolificURL when creating your experiment, as follows: magpieInit({ ... deploy: { deployMethod: \"Prolific\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); Use deploy method Prolific has two consequences. For one, it will insert a text input field in the introduction view of your experiment. For another, it will supply a confirm button at the end of the experiment, which takes participants to the Prolific website where they are supplied with their completion code. The data from your experiment will not be stored by Prolific, but recorded by the _magpie server app. Before launching the study on Prolific, double-check that the database on the back end is set up and the necessary information ( experimentID , server URL) are set. Also do not forget to update a web-site version of your experiment so that it includes the correct information in prolificURL before running the study.","title":"Recruitment via Prolific"},{"location":"03_deploying_experiments/03_recruitment_Prolific/#recruitment-via-prolific","text":"The following assumes that you are familiar with how to operate experiments with Prolific . Go to the Prolific website and create a new experiment. Make a note of the completion URL that is provided by Prolific. Enter the completion URL in the field prolificURL when creating your experiment, as follows: magpieInit({ ... deploy: { deployMethod: \"Prolific\", prolificURL: \"https://app.prolific.ac/submissions/complete?cc=SAMPLE1234\" } ... }); Use deploy method Prolific has two consequences. For one, it will insert a text input field in the introduction view of your experiment. For another, it will supply a confirm button at the end of the experiment, which takes participants to the Prolific website where they are supplied with their completion code. The data from your experiment will not be stored by Prolific, but recorded by the _magpie server app. Before launching the study on Prolific, double-check that the database on the back end is set up and the necessary information ( experimentID , server URL) are set. Also do not forget to update a web-site version of your experiment so that it includes the correct information in prolificURL before running the study.","title":"Recruitment via Prolific"},{"location":"03_deploying_experiments/04_hosting_on_netlify/","text":"Hosting on Netlify Registration Go to https://www.netlify.com/ and sign up using GitHub Deployment Using git: Click on the New site from Git -Button, choose GitHub and authorize the netlify-app on GitHub, configure which repositories to give access to, (back on netlify) select the repository to deploy, enter the build command rm -rf dist && mkdir dist && rsync -rv * dist --exclude ./dist and the publish directory dist (this is a workaround for publishing node_modules , see here , another way of bundling the files may be appropriate), click on Deploy site Manual: Go to https://app.netlify.com/ and drag and drop your finished experiment folder (including node_modules) to the drag&drop area Configuration Change the domain name: Click on the deployed site you want to configure, click on Domain setting , click on Edit site name and change to the name of choice.","title":"Hosting on netlify"},{"location":"03_deploying_experiments/04_hosting_on_netlify/#hosting-on-netlify","text":"Registration Go to https://www.netlify.com/ and sign up using GitHub Deployment Using git: Click on the New site from Git -Button, choose GitHub and authorize the netlify-app on GitHub, configure which repositories to give access to, (back on netlify) select the repository to deploy, enter the build command rm -rf dist && mkdir dist && rsync -rv * dist --exclude ./dist and the publish directory dist (this is a workaround for publishing node_modules , see here , another way of bundling the files may be appropriate), click on Deploy site Manual: Go to https://app.netlify.com/ and drag and drop your finished experiment folder (including node_modules) to the drag&drop area Configuration Change the domain name: Click on the deployed site you want to configure, click on Domain setting , click on Edit site name and change to the name of choice.","title":"Hosting on Netlify"}]}